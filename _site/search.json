[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html",
    "href": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "This code chunk below uses p_load() of pacman package to check if tidyverse packages are installed in the computer, If they are, then they will be launched into R. Also, this code chunk assumes that we have pacman package installed. If not, install pacman first.\n\npacman::p_load(tidyverse)\n\n\n\n\nThis code chuk below imports the exam_data.csv into the R environment by using the read_csv() function of readr package, which is one of the tidyverse package.\n\nexam_data <- read_csv(\"data/Exam_data.csv\")\n\nRows: 322 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): ID, CLASS, GENDER, RACE\ndbl (3): ENGLISH, MATHS, SCIENCE\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#r-graphics-vs-ggplot",
    "href": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#r-graphics-vs-ggplot",
    "title": "Hands-on Exercise 1",
    "section": "R Graphics vs ggplot",
    "text": "R Graphics vs ggplot\nR graphics\n\nhist(exam_data$MATHS)\n\n\n\n\nggplot2\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 10,\n                 boundary = 100,\n                 color = \"black\",\n                 fill = \"grey\") +\n  ggtitle(\"Distribution of Maths scores\")\n\n\n\n\nThen, why ggplot2? It is a powerful way of thinking about visualization, as a way of mapping between variables and the visual properties of geometric objects that you can perceive."
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#what-is-a-statistical-graph",
    "href": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#what-is-a-statistical-graph",
    "title": "Hands-on Exercise 1",
    "section": "What is a statistical graph?",
    "text": "What is a statistical graph?\nGrammar of graphics defines the rules of structuring mathematical and aesthetic elements into a meaningful graph. There are two principles; graphics = distinct layers of grammatical elements, and meaningful plots through aesthetic mapping.\nA good grammar will allow us to gain insight into the composition of complicated graphics, and reveal unexpected connections between seemingly different graphics. A grammar provides a strong foundation for understanding a diverse range of graphics. A grammar may also help guide us on what a well-formed or correct graphic looks like, but there will still be many grammatically correct but nonsensical graphics."
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#ggplot",
    "href": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#ggplot",
    "title": "Hands-on Exercise 1",
    "section": "ggplot()",
    "text": "ggplot()\nThis initializes a ggplot object. The data argument defines the dataset to be used for plotting. If the dataset is not already a data.frame, it will be converted to one by fortify()\n\nggplot(data = exam_data)"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#aesthetic-mapping",
    "href": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#aesthetic-mapping",
    "title": "Hands-on Exercise 1",
    "section": "Aesthetic mapping",
    "text": "Aesthetic mapping\nEach visual characteristic can encode an aspect of the data, and can beu sed to convey information. All aesthetics of the plot are specified in the aes() function call.\nThe code chunk on the right addes the aesthetic element into the plot. Notice that ggplot includes the x-axis and the axis’s labels.\n\nggplot(data = exam_data,\n       aes(x = MATHS))"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#geometric-objects",
    "href": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#geometric-objects",
    "title": "Hands-on Exercise 1",
    "section": "Geometric objects",
    "text": "Geometric objects\nThese are the actual marks we put on a plot. Examples include:\n\ngeom_point for drawing individual points (e.g., a scatter plot)\ngeom_line for drawing lines\ngeom_smooth for drawing smoothed lines (e.g., for simple trends)\ngeom_bar for drawing bars\ngeom_histogram for for drawing binned values, the default bin is 30\ngeom_polygon for drawing arbitrary shapes\ngeom_map for drawing polygons in the shape of a map\n\nA plot must have at least one geom; there is no upper limit. You can add a geom to a plot by using the + operator.\n\nGeom Objects: geom_dotplot\nIn a dot plot, the width of a ddot corresponds to the bin width (or max width), and dots are stacked, with each dot representing one observation. Be warned: The y scale is not very useful. In fact, it can be very misleading.\nIn the code chunk below, geom_dotplot() of ggplot2 is used to plot a dot plot.\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_dotplot(dotsize = 0.5)\n\nBin width defaults to 1/30 of the range of the data. Pick better value with\n`binwidth`.\n\n\n\n\n\nThs code chunk below performs the following:\n\nscale_y_continuous() is used to turn off the y-axis\nbinwidth argument is used to change the binwidth to 2.5\n\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_dotplot(binwidth = 2.5,\n               dotsize = 0.5) +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\n\n\n\n\n\nGeom Objects: geom_histogram()\nIn the code chunk below,\n\nbins argument is used to change the number of bins to 20\nfill argument is used to shade the histogram with light blue color\ncolor argument is used to change the outline color of the bars in black\n\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 color = \"black\",\n                 fill = \"light blue\")\n\n\n\n\nThe code chunk below changes the interior color of the histogram by using sub-group of aesthetic().\n\nggplot(data = exam_data,\n       aes(x = MATHS,\n           fill = GENDER)) +\n  geom_histogram(bins = 20,\n                 color = \"grey30\")\n\n\n\n\nThis approach can be used to color, fill and alpha of the geometric.\n\n\nGeometric Objects: geom-density\nThis computes and plots kernel density estimate, which is a smoothed version of the histogram. It is a useful alternative to the histogram for continuous data that comes from an underlying smooth distribution.\nThe code chunk below plots the distribution of Maths scores in a kernel density estimate plot.\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_density()\n\n\n\n\nThe code chunk below plots two kernel density lines by using colour or fill arguments of aes().\n\nggplot(data = exam_data,\n       aes(x = MATHS,\n           color = GENDER)) +\n  geom_density()\n\n\n\n\n\n\nGeometric Objects: geom_boxplot\nThis will display a continuous value list. It visualises the five number summary statistics and all outlying points individually.\nNotches are used in boxplots to help visually assess whether the medians of distributions differ. If the notches do not overlap, this is evidence that the medians are different.\nThe code chunk below plots the distribution of Maths scores by Gender in a notched plot instead of boxplot.\n\nggplot(data = exam_data,\n       aes(x = MATHS,\n           color = GENDER)) +\n  geom_boxplot(notch=TRUE)\n\n\n\n\n\n\nCombining Geometric Objects\nThe code chunk below plots the data points on the boxplots by using both geom_boxplot() and geom_point().\n\nggplot(data = exam_data,\n       aes(y = MATHS,\n           x = GENDER)) +\n  geom_boxplot() +\n  geom_point(position = \"jitter\",\n             size = 0.5)\n\n\n\n\n\n\nGeometric Objects: geom_violin\nThis is designed for creating violin plot. It is a way of comparing multiple data distributions. With ordinary distribution curves, it is difficult to compare more than just a few distributions because the lines virtually interfere with each other.\nWith a violin plot, it’s easier to compare several distributions since they’re packed side by side.\nThe code below plots the distribution of Maths score by Gender in a violin plot.\n\nggplot(data = exam_data,\n       aes(y = MATHS,\n           x = GENDER)) +\n  geom_violin()"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#statistics-stat",
    "href": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#statistics-stat",
    "title": "Hands-on Exercise 1",
    "section": "Statistics, stat",
    "text": "Statistics, stat\nThe Statistics functions statistically transforms data, usually as a some form of summary. There are two ways to use these functions:\n\nadd a stat_() function and override the default geom\nadd a geom_() function and oveeride the default stat\n\nThe code chunk below adds mean values by using stat_summary() function and overriding the default geom.\n\nggplot(data = exam_data, \n       aes(y = MATHS, x = GENDER)) +\n  geom_boxplot() +\n  stat_summary(geom = \"point\",       \n               fun.y = \"mean\",         \n               colour = \"red\",        \n               size = 4)      \n\nWarning: The `fun.y` argument of `stat_summary()` is deprecated as of ggplot2 3.3.0.\nℹ Please use the `fun` argument instead.\n\n\n\n\n\nThe code chunk below adds mean values by using geom_() function and overriding the default stat.\n\nggplot(data = exam_data, \n       aes(y = MATHS, x = GENDER)) +\n  geom_boxplot() +\n  geom_point(stat = \"summary\",\n             fun.y = \"mean\",\n             colour = \"red\", \n             size = 4)    \n\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n\n\nNo summary function supplied, defaulting to `mean_se()`"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#best-fit-curve",
    "href": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#best-fit-curve",
    "title": "Hands-on Exercise 1",
    "section": "Best Fit Curve",
    "text": "Best Fit Curve\nIn the code chunk below, geom_smooth() is used to plot a best fit curve on the scatteplot.\nThe default method used is loess:\n\nggplot(data = exam_data, \n       aes(x = MATHS, y = ENGLISH)) +\n  geom_point() +\n  geom_smooth(size = 0.5)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nThe default smoothing method can be overriden:\n\nggplot(data = exam_data, \n       aes(x = MATHS, y = ENGLISH)) +\n  geom_point() +\n  geom_smooth(method = lm,\n              size = 0.5)\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#facets",
    "href": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#facets",
    "title": "Hands-on Exercise 1",
    "section": "Facets",
    "text": "Facets\nFacetting generates small multiples (sometimes also called trellis plot), each displaying a different subset of the data, These are an alternative to aesthetics for displaying additional discrete variables. ggplot2 suports two types of facets; facet_grid() and facet_wrap().\n\nfacet_wrap()\nThis wraps a 1d sequence of panels into 2d. This is generally a better use of screen space than facet_grid because most displays are roughly rectangular.\nThe code chunk below plots a trellis plot using facet_wrap().\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20) +\n  facet_wrap(~ CLASS)\n\n\n\n\n\n\nfacet_grid()\nThis forms a matrix of panels defined by row and column facetting variables. It is most useful when you have two discrete variables, and all combinations of the variables exist in the data.\nThe code chunk below plots a trellis plot using facet_grid().\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20) +\n  facet_grid(~ CLASS)"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#coordinates",
    "href": "Hands_on_Ex/Hands_on_Ex01/Hands_on_Ex01.html#coordinates",
    "title": "Hands-on Exercise 1",
    "section": "Coordinates",
    "text": "Coordinates\nThe Coordinates functions map the position of objects onto the plane of the plot. There are a number of different possible coordinate systems to use:\n\ncoord_cartesian(): the default cartesian coordinate systems, where you specify x and y values\ncoord_flip(): a cartesian system with the x and y flipped\ncoord_fixed(): a cartesian system with a fixed aspect ration\ncoord_quickmap(): a coordinate system that approximates a good aspect ratio for maps\n\nBy default, the bar chart of ggplot2 is in vertical form. The code chunk below flips the horizontal bar chart into vertical bar chart by using coord_flip()\n\nggplot(data = exam_data,\n       aes(x = RACE)) +\n  geom_bar() +\n  coord_flip()\n\n\n\n\nThe code chunk below fixes both the y-axis and x-axis range from 0 to 100.\n\nggplot(data = exam_data, \n       aes(x = MATHS, y = ENGLISH)) +\n  geom_point() +\n  geom_smooth(method = lm, \n              size = 0.5) +  \n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100))\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex02/Hands_on_Ex02.html",
    "href": "Hands_on_Ex/Hands_on_Ex02/Hands_on_Ex02.html",
    "title": "Hands-on Exercise 2: Creating Elegent Graphics with ggplot2",
    "section": "",
    "text": "Before we get started, it is important for us to ensure that the required R packages have been installed. If yes, we will load the R packages. If they have yet to be installed, we will install the R packages and load them onto the R environment.\nThe chunk of code below will install and load the required libraries for this hands-on exercise.\n\npacman::p_load(tidyverse, patchwork, ggthemes, hrbrthemes, ggrepel)\n\n\n\n\nThe code chunk below imports exam_data.csv into the R environment using read_csv() function of readr package.\n\nexam_data <- read_csv(\"data/Exam_data.csv\")\n\nRows: 322 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): ID, CLASS, GENDER, RACE\ndbl (3): ENGLISH, MATHS, SCIENCE\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThere are a total of seven attributes, four of them are of categorical data type while the others are of continuous data type.\n\nCategorical attributes are: ID, CLASS, GENDER and RACE\nContinuous attributes are MATHS, ENGLISH and SCIENCE"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex02/Hands_on_Ex02.html#beyong-ggplot2-annotation",
    "href": "Hands_on_Ex/Hands_on_Ex02/Hands_on_Ex02.html#beyong-ggplot2-annotation",
    "title": "Hands-on Exercise 2: Creating Elegent Graphics with ggplot2",
    "section": "Beyong ggplot2 Annotation",
    "text": "Beyong ggplot2 Annotation\nOne of the challenges in plotting statistical graphs is annotation, especially with a large number of data points.\n\nWorking with ggrepel\nggrepel is an extension of ggplot2 package which provides geoms for ggplot2 to repel overlapping text. We simply replace geom_text() with geom_text_repel() and geom_label() with geom_label_repel().\n\nggplot(data = exam_data,\n       aes(x = MATHS,\n           y = ENGLISH)) +\n  geom_point() +\n  geom_smooth(method = lm,\n              size = 0.5) +\n  geom_label_repel(aes(label = ID),\n                   fontface = \"bold\") +\n  coord_cartesian(xlim = c(0, 100),\n                  ylim = c(0, 100)) +\n  ggtitle(\"English scores versus Maths scores for Primary 3\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: ggrepel: 317 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex02/Hands_on_Ex02.html#beyond-ggplot2-themes",
    "href": "Hands_on_Ex/Hands_on_Ex02/Hands_on_Ex02.html#beyond-ggplot2-themes",
    "title": "Hands-on Exercise 2: Creating Elegent Graphics with ggplot2",
    "section": "Beyond ggplot2 Themes",
    "text": "Beyond ggplot2 Themes\nggplot2 comes with eight built-in themes. They are\n\ntheme_gray()\ntheme_bw()\ntheme_classic()\ntheme_dark()\ntheme_light()\ntheme_linedraw()\ntheme_minimal()\ntheme_void()\n\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"grey25\",\n                 fill = \"grey90\") +\n  theme_gray() +\n  ggtitle(\"Distribution of Maths scores\")\n\n\n\n\n\nWorking with ggtheme package\nggthemes provides ggplot2 themes with the ability to replicate the look of plots. It also provides extra geoms and scales for ggplot2.\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"grey25\",\n                 fill = \"grey90\") +\n  ggtitle(\"Distribution of Maths scores\") +\n  theme_economist()\n\n\n\n\n\n\nWorking with hrbrthemes package\nhrbrthemes package provides a basic theme that focuses on typographic elements, including where various labels are placed as well as the fonts that are used.\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"grey25\",\n                 fill = \"grey90\") +\n  ggtitle(\"Distribution of Maths scores\") +\n  theme_ipsum()\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)): font family not\nfound in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\n\n\n\n\naxis_title_size argument is used to increase the font size of the axis title\nbase_size argument is used to increase the default axis label to 15\ngrid argument is used to remove the x-axis grid lines\n\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"grey25\",\n                 fill = \"grey90\") +\n  ggtitle(\"Distribution of Maths scores\") +\n  theme_ipsum()\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database\n\n\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nfont family not found in Windows font database\n\n\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : font\nfamily not found in Windows font database"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex02/Hands_on_Ex02.html#beyond-ggplot2-facet",
    "href": "Hands_on_Ex/Hands_on_Ex02/Hands_on_Ex02.html#beyond-ggplot2-facet",
    "title": "Hands-on Exercise 2: Creating Elegent Graphics with ggplot2",
    "section": "Beyond ggplot2 facet",
    "text": "Beyond ggplot2 facet\nIn this section, we will be creating composite plots by combining multiple graphs. First, let’s create three statistical graphs.\n\np1 <- ggplot(data = exam_data, \n             aes(x = MATHS)) +\n  geom_histogram(bins = 20, \n                 boundary = 100,\n                 color = \"grey25\", \n                 fill = \"grey90\") + \n  coord_cartesian(xlim = c(0,100)) +\n  ggtitle(\"Distribution of Maths scores\")\n\np2 <- ggplot(data = exam_data, \n             aes(x = ENGLISH)) +\n  geom_histogram(bins = 20, \n                 boundary = 100,\n                 color = \"grey25\", \n                 fill = \"grey90\") +\n  coord_cartesian(xlim = c(0,100)) +\n  ggtitle(\"Distribution of English scores\")\n\np3 <- ggplot(data = exam_data, \n             aes(x = MATHS, \n                 y =ENGLISH)) +\n  geom_point() +\n  geom_smooth(method = lm, \n              size = 0.5) +  \n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100)) +\n  ggtitle(\"English scores versus Maths scores for Primary 3\")\n\n\nCreating Composite Graphics: patchwork methods\nSometimes, multiple graphs are required to tell a compelling visual story. There are several ggplot2 extensions that provide functions to compose figures with multiple graphs.\nPatchwork package has a very simple syntax where we can create layouts super easily. The general syntax combines a two-column layout using the plus sign, a parenthesis to create a subplot group and a two row layout using the division sign.\nTry this:\n\np1 + p2 / p3\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n‘|’ will place the plots beside each other while ‘/’ will stack them:\n\n(p1 / p2) | p3\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nPatchwork also provides auto-tagging capabilities which aim to identify subplots in text:\n\n((p1 / p2) | p3) +\n  plot_annotation(tag_levels = 'I')\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nTo add themes:\n\npatchwork <- (p1 / p2) | p3\npatchwork & theme_economist()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nBesides providing functions to place plots next to each other based on the provided layout, patchwork also allows us to place one or several plots of graphic elements freely on top or below another plot.\n\np3 + inset_element(p2,\n                    left = 0.02,\n                    bottom = 0.7,\n                    right = 0.5,\n                    top = 1)\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html",
    "href": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html",
    "title": "Hands-on Exercise 3: Programming Interactive Data Visualization with R",
    "section": "",
    "text": "The code chunk below will install and launch the necessary R packages.\n\npacman::p_load(ggiraph, plotly, gganimate, DT, tidyverse, patchwork)"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#importing-data",
    "href": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#importing-data",
    "title": "Hands-on Exercise 3: Programming Interactive Data Visualization with R",
    "section": "Importing Data",
    "text": "Importing Data\nThe code chunk below will read the Exam_data.csv file.\n\nexam_data <- read_csv(\"data/Exam_data.csv\")\n\nRows: 322 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): ID, CLASS, GENDER, RACE\ndbl (3): ENGLISH, MATHS, SCIENCE\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#interactive-data-visualization---ggiraph-methods",
    "href": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#interactive-data-visualization---ggiraph-methods",
    "title": "Hands-on Exercise 3: Programming Interactive Data Visualization with R",
    "section": "Interactive Data Visualization - ggiraph methods",
    "text": "Interactive Data Visualization - ggiraph methods\nggiraph is a html-widget and a ggplot2 extension. It allows ggplot graphics to be interactive. This interactivity is made with ggplot geometries that can take in three arguments:\n\ntooltip: a column of datasets that contain tooltips to be displayed when the mouse if over elements\nonclick: a column of datasets that contain a JavaScript function to be executed when elements are clicked\ndata_id: a column of datasets that contain an id to be associated with elements\n\nWhen used within a R shiny application, elements associated with an id (data_id) can be selected and manipulated on client and server sides.\n\nTooltip Effects\nThe code chunk below will plot an interactive statistical graph using the ggiraph package. This code chunk consists of two parts - the first part is to plot a ggplot object while the next part will use girage() of ggiraph to create an interactive svg object.\n\np <- ggplot(data = exam_data,\n           aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(tooltip = ID),\n                           stackgroups = TRUE,\n                           binwidth = 1,\n                           method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(ggobj = p,\n       width_svg = 6,\n       height_svg = 6 * 0.618)\n\n\n\n\n\n\n\nMultiple Info on Tooltips\nThe content of the tooltip can be customized as shown in the code chunk below.\n\nexam_data$tooltip <- c(paste0(\"Name = \", exam_data$ID,\n                              \"\\nClass = \", exam_data$CLASS))\n\np <- ggplot(data = exam_data,\n           aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(tooltip = exam_data$tooltip),\n                           stackgroups = TRUE,\n                           binwidth = 1,\n                           method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(ggobj = p,\n       width_svg = 8,\n       height_svg = 8 * 0.618)\n\n\n\n\n\n\n\nCustomizing Tooltip Style\nThe code chunk below uses opts_tooltip() of ggiraph to customize the tooltip rendering by adding css declarations.\n\ntooltip_css <- \"background-color: white; font-style: bold; color: black;\"\n\np <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(tooltip = ID),\n                           stackgroups = TRUE,\n                           binwidth = 1,\n                           method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(ggobj = p,\n       width_svg = 6,\n       height_svg = 6 * 0.618,\n       options = list(opts_tooltip(css = tooltip_css)))\n\n\n\n\n\n\n\nDisplaying Statistics on Tooltips\nThe code chunk below shows an advanced way to customize tooltips. In this example, a function is sued to compute the 90% confidence interval of the mean, and the derived statistics will then be displayed in the tooltip.\n\ntooltip <- function(y, ymax, accuracy = .01) {\n  mean <- scales::number(y, accuracy = accuracy)\n  sem <- scales::number(ymax - y, accuracy = accuracy)\n  paste(\"Mean maths scores:\", mean, \"+/-\", sem)\n}\n\ngg_point <- ggplot(data = exam_data,\n                   aes(x = RACE)) +\n  stat_summary(aes(y = MATHS,\n                   tooltip = after_stat(tooltip(y, ymax))),\n               fun.data = \"mean_se\",\n               geom = GeomInteractiveCol,\n               fill = \"light blue\") +\n  stat_summary(aes(y = MATHS),\n               fun.data = mean_se,\n               geom = \"errorbar\",\n               width = 0.2,\n               size = 0.2)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\ngirafe(ggobj = gg_point,\n       width_svg = 8,\n       height_svg = 8 * 0.618)\n\n\n\n\n\n\n\nHover Effect with Aesthetic\nThe code chunk below shows the second interactive feature of ggiraph, namely data_id.\n\np <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(data_id = CLASS),\n                           stackgroups = TRUE,\n                           binwidth = 1,\n                           method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(\n  ggobj = p,\n  width_svg = 6,\n  height_svg = 6 * 0.618\n)\n\n\n\n\n\nThe default value of the hover css is hover_css = “fill: orange;”.\n\n\nStyling Hover Effect\nIn the code chunk below, css codes are used to change the highlighting effect.\n\np <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(data_id = CLASS),\n                           stackgroups = TRUE,\n                           binwidth = 1,\n                           method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(\n  ggobj = p,\n  width_svg = 6,\n  height_svg = 6 * 0.618,\n  options = list(opts_hover(css = \"fill: #202020;\"),\n                 opts_hover_inv(css = \"opacity: 0.2;\"))\n)\n\n\n\n\n\n\n\nCombining Tooltip and Hover Effect\nThere are times that we want to combine the tooltip and hover effect on the interactive statistical graph. The code chunk below achieves this:\n\np <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(tooltip = CLASS,\n                                data_id = CLASS),\n                            stackgroups = TRUE,\n                            binwidth = 1,\n                            method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(ggobj = p,\n       width_svg = 6,\n       height_svg = 6 * 0.618,\n       options = list(opts_hover(css = \"fill: #202020;\"),\n                      opts_hover_inv(css = \"opacity: 0.2;\")))\n\n\n\n\n\n\n\nClick Effect with onclick\nThe onclick argument of ggiraph provides hotlink interactivity on the web. The code chunk below shows an example of onclick.\n\nexam_data$onclick <- sprintf(\"window.open(\\\"%s%s\\\")\",\n\"https://www.moe.gov.sg/schoolfinder?journey=Primary%20school\",\nas.character(exam_data$ID))\n\np <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(onclick = onclick),\n                            stackgroups = TRUE,\n                            binwidth = 1,\n                            method = \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(ggobj = p,\n       width_svg = 6,\n       height_svg = 6 * 0.618)\n\n\n\n\n\nNote that click actions must be a string column in the dataset containing valid javascript instructions.\n\n\nCoordinated Multiple Views\nAn example of this method; when a data point of one of the dotplot is selected, the corresponding data point ID on the second data visualization will also be highlighted.\nFor this to be built, we need to use an appropriate interactive function of ggiraph to create the multiple views. Also, patchwork function of the patchwork package will be used inside the girafe function to create the interactive coordinated multiple views.\n\np1 <- ggplot(data = exam_data,\n             aes(x = MATHS)) + \n  geom_dotplot_interactive(aes(data_id = ID),\n                           stackgroups = TRUE,\n                           binwidth = 1,\n                           method = \"histodot\") +\n  coord_cartesian(xlim = c(0, 100)) +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\np2 <- ggplot(data = exam_data,\n             aes(x = ENGLISH)) + \n  geom_dotplot_interactive(aes(data_id = ID),\n                           stackgroups = TRUE,\n                           binwidth = 1,\n                           method = \"histodot\") +\n  coord_cartesian(xlim = c(0, 100)) +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(code = print(p1 / p2),\n       width_svg = 6,\n       height_svg = 6,\n       options = list(opts_hover(css = \"fill: #202020;\"),\n                      opts_hover_inv(css = \"opacity: 0.2;\")))\n\n\n\n\n\nThe data_id aesthetic is critical to link observations between plots and the tooltip aesthetic is optional but nice to have when we hover over a data point."
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#interactive-data-visualization---plotly-methods",
    "href": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#interactive-data-visualization---plotly-methods",
    "title": "Hands-on Exercise 3: Programming Interactive Data Visualization with R",
    "section": "Interactive Data Visualization - plotly methods",
    "text": "Interactive Data Visualization - plotly methods\nPlotly’s R graphing library can create interactive web graphics from ggplot2 graphs. This is different from other plotly platforms as plot.R is free and open-source.\nThere are two ways to create interactive graphs using plotly - by using plot_ly() or by using ggplotly().\n\nCreating Interactive Scatter Plot: plot_ly() method\nThe code chunk below plots an interactive scatter plot using plot_ly().\n\nplot_ly(data = exam_data,\n        x = ~MATHS,\n        y = ~ENGLISH)\n\nNo trace type specified:\n  Based on info supplied, a 'scatter' trace seems appropriate.\n  Read more about this trace type -> https://plotly.com/r/reference/#scatter\n\n\nNo scatter mode specifed:\n  Setting the mode to markers\n  Read more about this attribute -> https://plotly.com/r/reference/#scatter-mode\n\n\n\n\n\n\n\n\nVisual Variable: plot_ly() method\nIn the code chunk below, the color argument is mapped to a qualitative visual variable.\n\nplot_ly(data = exam_data,\n        x = ~MATHS,\n        y = ~ENGLISH,\n        color = ~RACE)\n\nNo trace type specified:\n  Based on info supplied, a 'scatter' trace seems appropriate.\n  Read more about this trace type -> https://plotly.com/r/reference/#scatter\n\n\nNo scatter mode specifed:\n  Setting the mode to markers\n  Read more about this attribute -> https://plotly.com/r/reference/#scatter-mode\n\n\n\n\n\n\nWe can click on the color symbols at the legend for interactivity.\n\n\nChanging Color Palette: plot_ly() method\nIn the code chunk below, colors argument is used to change the default color palette to ColorBrewel color palette.\n\nplot_ly(data = exam_data,\n        x = ~MATHS,\n        y = ~ENGLISH,\n        color = ~RACE,\n        colors = \"Set1\")\n\nNo trace type specified:\n  Based on info supplied, a 'scatter' trace seems appropriate.\n  Read more about this trace type -> https://plotly.com/r/reference/#scatter\n\n\nNo scatter mode specifed:\n  Setting the mode to markers\n  Read more about this attribute -> https://plotly.com/r/reference/#scatter-mode\n\n\n\n\n\n\n\n\nCustomizing Color Scheme: plot_ly() method\nIn the code chunk below, a customized color scheme is created. Then, the colors argument is used to change the default color palette to the customized color scheme.\n\npal <- c(\"red\", \"purple\", \"blue\", \"green\")\n\nplot_ly(data = exam_data,\n        x = ~MATHS,\n        y = ~ENGLISH,\n        color = ~RACE,\n        colors = pal)\n\nNo trace type specified:\n  Based on info supplied, a 'scatter' trace seems appropriate.\n  Read more about this trace type -> https://plotly.com/r/reference/#scatter\n\n\nNo scatter mode specifed:\n  Setting the mode to markers\n  Read more about this attribute -> https://plotly.com/r/reference/#scatter-mode\n\n\n\n\n\n\n\n\nCustomizing Tooltip: plot_ly() method\nIn the code chunk below, the text argument is used to change the default tooltip.\n\nplot_ly(data = exam_data,\n        x = ~MATHS,\n        y = ~ENGLISH,\n        text = ~paste(\"Student ID:\", ID,\n                      \"<br>Class:\", CLASS),\n        color = ~RACE,\n        colors = \"Set1\")\n\nNo trace type specified:\n  Based on info supplied, a 'scatter' trace seems appropriate.\n  Read more about this trace type -> https://plotly.com/r/reference/#scatter\n\n\nNo scatter mode specifed:\n  Setting the mode to markers\n  Read more about this attribute -> https://plotly.com/r/reference/#scatter-mode\n\n\n\n\n\n\n\n\nLayouts: plot_ly() method\nIn the code chunk below, the layout argument is used to change the default tooltip.\n\nplot_ly(data = exam_data,\n        x = ~MATHS,\n        y = ~ENGLISH,\n        text = ~paste(\"Student ID:\", ID,\n                      \"<br>Class:\", CLASS),\n        color = ~RACE,\n        colors = \"Set1\") %>%\n  layout(title = \"English Score vs. Maths Score\",\n         xaxis = list(range = c(0, 100)),\n         yaxis = list(range = c(0, 100)))\n\nNo trace type specified:\n  Based on info supplied, a 'scatter' trace seems appropriate.\n  Read more about this trace type -> https://plotly.com/r/reference/#scatter\n\n\nNo scatter mode specifed:\n  Setting the mode to markers\n  Read more about this attribute -> https://plotly.com/r/reference/#scatter-mode\n\n\n\n\n\n\n\n\nCreating Interactive Scatter Plot: ggplotly() method\nThe code chunk below plots an interactive scatter plot using ggplotly().\n\np <- ggplot(data = exam_data,\n            aes(x = MATHS,\n                y = ENGLISH)) +\n  geom_point(dotsize = 1) +\n  coord_cartesian(xlim = c(0, 100),\n                  ylim = c(0, 100))\n\nWarning in geom_point(dotsize = 1): Ignoring unknown parameters: `dotsize`\n\nggplotly(p)\n\n\n\n\n\n\n\nCoordinated Multiple Views with plotly\nThe code chunk below plots two scatter plots and places them next to each other side-by-side by using subplot() of plotly package.\n\np1 <- ggplot(data = exam_data,\n            aes(x = MATHS,\n                y = ENGLISH)) +\n  geom_point(dotsize = 1) +\n  coord_cartesian(xlim = c(0, 100),\n                  ylim = c(0, 100))\n\nWarning in geom_point(dotsize = 1): Ignoring unknown parameters: `dotsize`\n\np2 <- ggplot(data = exam_data,\n            aes(x = MATHS,\n                y = SCIENCE)) +\n  geom_point(dotsize = 1) +\n  coord_cartesian(xlim = c(0, 100),\n                  ylim = c(0, 100))\n\nWarning in geom_point(dotsize = 1): Ignoring unknown parameters: `dotsize`\n\nsubplot(ggplotly(p1),\n        ggplotly(p2))\n\n\n\n\n\nTo be able to click on a data point of one of the scatter plot and see how the corresponding point on the other scatter plot is selected, try out the following code chunk,\n\nd <- highlight_key(exam_data)\n\np1 <- ggplot(data = d,\n            aes(x = MATHS,\n                y = ENGLISH)) +\n  geom_point(dotsize = 1) +\n  coord_cartesian(xlim = c(0, 100),\n                  ylim = c(0, 100))\n\nWarning in geom_point(dotsize = 1): Ignoring unknown parameters: `dotsize`\n\np2 <- ggplot(data = d,\n            aes(x = MATHS,\n                y = SCIENCE)) +\n  geom_point(dotsize = 1) +\n  coord_cartesian(xlim = c(0, 100),\n                  ylim = c(0, 100))\n\nWarning in geom_point(dotsize = 1): Ignoring unknown parameters: `dotsize`\n\nsubplot(ggplotly(p1),\n        ggplotly(p2))"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#interactive-data-visualization---crosstalk-methods",
    "href": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#interactive-data-visualization---crosstalk-methods",
    "title": "Hands-on Exercise 3: Programming Interactive Data Visualization with R",
    "section": "Interactive Data Visualization - crosstalk methods",
    "text": "Interactive Data Visualization - crosstalk methods\nCrosstalk is an add-on to the html-widgets package. It extends html-widgets with a set of classes, functions and conventions for implementation cross-widget interactions.\n\nInteractive Data Table: DT package\nThis is a wrapper of the JavaScript library DataTables. With this, data objects in R can be rendered as HTML tables.\n\nDT::datatable(exam_data, class = \"compact\")\n\n\n\n\n\n\n\n\nLinked Brushing: crosstalk method\nIn the code chunk below, we can implement coordinated brushing.\n\nd <- highlight_key(exam_data)\n\np <- ggplot(data = d,\n            aes(x = MATHS,\n                y = ENGLISH)) +\n  geom_point(dotsize = 1) +\n  coord_cartesian(xlim = c(0, 100),\n                  ylim = c(0, 100))\n\nWarning in geom_point(dotsize = 1): Ignoring unknown parameters: `dotsize`\n\ngg <- highlight(ggplotly(p),\n                \"plotly_selected\")\n\ncrosstalk::bscols(gg,\n                  DT::datatable(d),\n                  widths = 5)\n\nSetting the `off` event (i.e., 'plotly_deselect') to match the `on` event (i.e., 'plotly_selected'). You can change this default via the `highlight()` function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe highlight() is a function of plotly package. It sets a variety of options for brushing (i.e., highlighting) of multiple plots. These options are primarily designed for linking multiple plotly graphs and may not behave as expected when linking plotly to another html-widget package via crosstalk. In some cases, other html-widgets will respect these options such as persistent selection in leaflet.\nbscols() is a helper function of crosstalk package. It makes it easy to put HTML elements side by side. It can be called directly from the console but it is especially designed to work in an R Markdown document. Just a warning, this will bring in all of Bootstrap."
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#animated-data-visualization-gganimate-methods",
    "href": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#animated-data-visualization-gganimate-methods",
    "title": "Hands-on Exercise 3: Programming Interactive Data Visualization with R",
    "section": "Animated Data Visualization: gganimate methods",
    "text": "Animated Data Visualization: gganimate methods\ngganimate extends the grammar of graphics as implemented by ggplot2 to include the description of animation. It does this by providing a range of new grammar classes that can be added to the plot object in order to customize how it should with time.\n\ntransition_*() defines how the data should be spread out and how it relates to itself across time\nview_*() defines how the positional scales should change along the animation\nshadow_*() defines how the data from other points in time should be presented in the given point in time\nenter_() / exit_() defines how new data should appear and how old data should disappear during the course of the animation\nease_aes() defines how different aesthetics should be eased during transitions\n\n\nGetting Started\nLet’s install and load the following packages:\n\ngganimate is a ggplot extension for creating animated statistical graphs\ngifski converts video frames to GIF animations using pngquant’s fancy features for efficient cross-frame palettes and temporal dithering, and it produces animated GIFs that use thousands of colors per frame\ngapminder is an excerpt of the data available at Gapminder.org, and we will just be using their country_colors scheme\n\n\npacman::p_load(gganimate, gifski, gapminder, readxl, dplyr)\n\n\n\nImporting Data\nThe code chunk below will import the Data worksheet from the GlobalPopulation excel file using the appropriate R package from the tidyverse family.\n\ncol <- c(\"Country\", \"Continent\")\n\nglobalPop <- read_xls(\"data/GlobalPopulation.xls\",\n                      sheet = \"Data\") %>%\n  mutate_each_(funs(factor(.)), col) %>%\n  mutate(Year = as.integer(Year))\n\nWarning: `mutate_each_()` was deprecated in dplyr 0.7.0.\nℹ Please use `across()` instead.\n\n\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nℹ Please use a list of either functions or lambdas:\n\n# Simple named list: list(mean = mean, median = median)\n\n# Auto named with `tibble::lst()`: tibble::lst(mean, median)\n\n# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\n\n\n\nread_xls() of readxl package is used to import the Excel worksheet\nmutate_each_() of dplyr package is used to convert all character data types into factor\nmutate() of dplyr package is used to convert all data values of Year field into interger\n\n\n\nStatic Bubble Plot\nIn the code chunk below, the basic ggplot2 functions are used to create a static bubble plot.\n\nggplot(globalPop,\n       aes(x = Old,\n           y = Young,\n           size = Population,\n           colour = Country)) +\n  geom_point(alpha = 0.7,\n             show.legend = FALSE) +\n  scale_colour_manual(values = country_colors) +\n  scale_size(range = c(2, 12)) +\n  labs(title = \"Year: {frame_time}\",\n       x = \"% Aged\",\n       y = \"% Young\")\n\n\n\n\n\n\nAnimated Bubble Plot\nIn the code chunk below, transition_time() of gganimate is used to create transition through distinct states in time. ease_aes() is also used to control the easing of aesthetics. The default in this case is linear. Other methods include quadratic, cubic, quartic, quintic, sine, circular, exponential, elastic, back and bounce.\n\nggplot(globalPop,\n       aes(x = Old,\n           y = Young,\n           size = Population,\n           colour = Country)) +\n  geom_point(alpha = 0.7,\n             show.legend = FALSE) +\n  scale_colour_manual(values = country_colors) +\n  scale_size(range = c(2, 12)) +\n  labs(title = \"Year: {frame_time}\",\n       x = \"% Aged\",\n       y = \"% Young\") +\n  transition_time(Year) +\n  ease_aes(\"linear\")"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#visualizing-large-data-interactively",
    "href": "Hands_on_Ex/Hands_on_Ex03/Hands_on_Ex03.html#visualizing-large-data-interactively",
    "title": "Hands-on Exercise 3: Programming Interactive Data Visualization with R",
    "section": "Visualizing Large Data Interactively",
    "text": "Visualizing Large Data Interactively\nWe can visualize large data by using packed bar methods. Let’s first import the datasets using read_csv() of readr package.\n\npacman::p_load(readr, tidyr)\n\nGDP <- read_csv(\"data/GDP.csv\")\n\nRows: 648 Columns: 25\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (25): Country Name, Country Code, Series Name, Series Code, 2000, 2001, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nWorldCountry <- read_csv(\"data/WorldCountry.csv\")\n\nRows: 250 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): Country or Area, ISO-alpha3 Code, Region 1, Region 2, Continent\ndbl (2): No, M49 Code\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nData Preparation\nBefore programming the data visualization, it is important for us to reshape, wrangle and transform the raw data to meet the data visualization needs. The code chunk below performs the following tasks:\n\nmutate() of dplyr package is used to convert all values in the 202 field into numeric data type\nselect() of dplyr package is used to extract columns 1 to 3 and values field\npivot_wider() of tidyr package is used to split the values in Series Name field into columns\nleft_join() of dplyr package is used to perform a left-join by using Country Code of GDP_selected and ISO-alpha3 Code of WorldCountry as unique identifiers\n\n\nGDP_selected <- GDP %>%\n  mutate(Values = as.numeric(`2020`)) %>%\n  select(1:3, Values) %>%\n  pivot_wider(names_from = `Series Name`,\n              values_from = `Values`) %>%\n  left_join(y = WorldCountry, \n            by = c(\"Country Code\" = \"ISO-alpha3 Code\"))\n\nWarning in mask$eval_all_mutate(quo): NAs introduced by coercion\n\n\n\n\nPacked Bar Method\npacked bar is a relatively new data visualization method introduced from JMP. It aims to support the need of visualizing skewed data over hundreds of categories. The idea is to support the focus + context data visualization principle.\nAs usual, we need to prepare the data before building the packed bar. The code chunk below does this preparation.\n\nGDP_selected <- GDP %>%\n  mutate(GDP = as.numeric(`2020`)) %>%\n  filter(`Series Name` == \"GDP (current US$)\") %>%\n  select(1:2, GDP) %>%\n  na.omit()\n\nWarning in mask$eval_all_mutate(quo): NAs introduced by coercion\n\n\nThe na.omit() is used to exclude rows with missing values. This is because rPackedBar package does not support missing values.\nIn the code chunk below, plotly_packed_bar() of rPackedBar package is used to create an interactive packed bar.\n\npacman::p_load(rPackedBar)\n\np = plotly_packed_bar(\n  input_data = GDP_selected,\n  label_column = \"Country Name\",\n  value_column = \"GDP\",\n  number_rows = 10,\n  plot_title = \"Top 10 countries by GDP, 2020\",\n  xaxis_label = \"GDP (US$)\",\n  hover_label = \"GDP\",\n  min_label_width = 0.018,\n  color_bar_color = \"#00aced\",\n  label_color = \"white\")\nplotly::config(p, displayModeBar = FALSE)\n\nWarning: `line.width` does not currently support multiple values.\n\nWarning: `line.width` does not currently support multiple values."
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex04/Hands_on_Ex04a.html",
    "href": "Hands_on_Ex/Hands_on_Ex04/Hands_on_Ex04a.html",
    "title": "Hands-on Exercise 4: Visual Statistical Analysis",
    "section": "",
    "text": "Visual Analysis with ggstatsplot\n\nAn extension of ggplot2 package for creating graphics with details from statistical tests included in the plot themselves\nProvides an alternative statistical inference method by default\nFollows best practices for statistical reporting\n\nFor all statistical tests reported in the plots, the default template abides by the APA gold standard for statistical reporting\n\nInstalling & Launching Packages\nIn this exercise, we will be using ggstatsplot and tidyverse.\n\npacman::p_load(ggstatsplot, tidyverse)\n\nImport the data for this exercise:\n\nexam <- read_csv(\"data/Exam_data.csv\")\n\nRows: 322 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): ID, CLASS, GENDER, RACE\ndbl (3): ENGLISH, MATHS, SCIENCE\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\nOne Sample Test\nIn the code chunk below, gghistostats() is used to build a visual of one-sample test on English scores. More information can be found here: https://indrajeetpatil.github.io/ggstatsplot/reference/gghistostats.html\n\nset.seed(1234)\n\ngghistostats(\n  data = exam,\n  x = ENGLISH,\n  type = \"bayes\",\n  test.value = 60,\n  xlab = \"English Scores\"\n)\n\n\n\n\n\n\nBayes Factor\n\nA Bayes factor is the ratio of the likelihood of one particular hypothesis to the likelihood of another\nCan be interpreted as a measure of the strength of evidence in favor of one theory among two competing theories\nBayes factor gives us a way to evaluate the data in favor of a null hypothesis, and allows us to use external information to do so\nIt tells us what the weight of the evidence is in favor of a give hypothesis\nWhen comparing two hypotheses, H1 (alternate hypotheses) and H0 (null hypothesis), the Bayes factor is often written as B10\nThe Schwarz criterion is one of the easiest ways to calculate rough approximation of the Bayes factor\n\n\n\nTwo Sample Mean Test\nIn the code chunk below, ggbetweenstats() is used to build a visual for two-sample mean test of Maths score by gender.\n\nggbetweenstats(\n  data = exam,\n  x = GENDER,\n  y = MATHS,\n  type = \"np\",\n  messages = FALSE\n)\n\n\n\n\n\n\nOne way ANOVA Test\nIn the code chunk below, ggbetweenstats() is used to build a visual for One-way ANOVA test on English scores by race.\n\nggbetweenstats(\n  data = exam,\n  x = RACE,\n  y = ENGLISH,\n  type = \"p\",\n  mean.ci = TRUE,\n  pairwise.comparisons = TRUE,\n  pairwise.display = \"s\",\n  p.adjust.method = \"fdr\",\n  messages = FALSE\n)\n\n\n\n\n\n\nSignificant Test of Correlation\nIn the code chunk below, ggscatterstats() is used to build a visual for Significant Test of of Correlation between Maths scores and English scores.\n\nggscatterstats(\n  data = exam,\n  x = MATHS,\n  y = ENGLISH,\n  margina = FALSE\n)\n\n\n\n\n\n\nSignificant Test of Association\nIn the code chunk below, the Maths scores is binned into a 4-class variable by using cut().\n\nexam1 <- exam %>%\n  mutate(MATHS_bins = cut(MATHS,\n                          breaks = c(0, 60, 75, 85, 100)))\n\nIn the code chunk below, ggbarstats() is used to build a visual for Significant Test of Association.\n\nggbarstats(\n  exam1, \n  x = MATHS_bins,\n  y = GENDER\n)\n\n\n\n\n\n\n\nVisualizing Models\nIn this section, we will visualize model diagnostic and model parameters by using the parameters package.\n\nInstalling & Launching Packages\nIn this exercise, we will be using the following libraries:\n\npacman::p_load(readxl, performance, parameters, see)\n\nImport the data for this exercise:\n\ncarResale <- read_xls(\"data/ToyotaCorolla.xls\",\n                      \"data\")\n\n\n\nMultiple Regression Model\nThe code chunk below is used to calibrate a multiple linear regression model by using lm() of Base Stats of R.\n\nmodel <- lm(Price ~ Age_08_04 + Mfg_Year + KM + Weight + Guarantee_Period,\n            data = carResale)\nmodel\n\n\nCall:\nlm(formula = Price ~ Age_08_04 + Mfg_Year + KM + Weight + Guarantee_Period, \n    data = carResale)\n\nCoefficients:\n     (Intercept)         Age_08_04          Mfg_Year                KM  \n      -2.637e+06        -1.409e+01         1.315e+03        -2.323e-02  \n          Weight  Guarantee_Period  \n       1.903e+01         2.770e+01  \n\n\n\n\nChecking for Multicolinearity\n\ncheck_collinearity(model)\n\n# Check for Multicollinearity\n\nLow Correlation\n\n             Term   VIF     VIF 95% CI Increased SE Tolerance Tolerance 95% CI\n Guarantee_Period  1.04   [1.01, 1.17]         1.02      0.97     [0.86, 0.99]\n        Age_08_04 31.07 [28.08, 34.38]         5.57      0.03     [0.03, 0.04]\n         Mfg_Year 31.16 [28.16, 34.48]         5.58      0.03     [0.03, 0.04]\n\nHigh Correlation\n\n   Term  VIF   VIF 95% CI Increased SE Tolerance Tolerance 95% CI\n     KM 1.46 [1.37, 1.57]         1.21      0.68     [0.64, 0.73]\n Weight 1.41 [1.32, 1.51]         1.19      0.71     [0.66, 0.76]\n\n\n\ncheck_c <- check_collinearity(model)\nplot(check_c)\n\nVariable `Component` is not in your data frame :/\n\n\n\n\n\n\n\nChecking Normality Assumption\n\nmodel1 <- lm(Price ~ Age_08_04 + KM + Weight + Guarantee_Period,\n            data = carResale)\ncheck_n <- check_normality(model1)\nplot(check_n)\n\n\n\n\n\n\nChecking for Homogeneity of Variances\n\ncheck_h <- check_heteroscedasticity(model1)\nplot(check_h)\n\n\n\n\n\n\nComplete Check\n\ncheck_model(model1)\n\nVariable `Component` is not in your data frame :/\n\n\n\n\n\n\n\nVisualizing Regression Parameters\nIn the code chunk below, plot() of see package and parameters() of parameters package is used to visualize the parameters of a regression model.\n\nplot(parameters(model1))\n\n\n\n\nIn the code chunk below, ggcoefstats() of ggstatsplot package is used to visualize the parameters of a regression model.\n\nggcoefstats(model1,\n            output = \"plot\")"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex04/Hands_on_Ex04b.html",
    "href": "Hands_on_Ex/Hands_on_Ex04/Hands_on_Ex04b.html",
    "title": "Hands-on Exercise 4: Visualizing Uncertainty",
    "section": "",
    "text": "Visualizing Uncertainty of Point Estimates\n\nA point estimate is a single number, such as a mean\nUncertainty is expressed as standard error, confidence interval or credible interval\nDo not confuse the uncertainty of a point estimate with the variation in the sample\n\n\npacman::p_load(tidyverse, plotly, crosstalk, DT, ggdist, gganimate)\nexam <- read_csv(\"data/Exam_data.csv\")\n\nRows: 322 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): ID, CLASS, GENDER, RACE\ndbl (3): ENGLISH, MATHS, SCIENCE\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThe code chunk below performs the following: - groups the observation by RACE - computes the count of observations, means, standard deviation and standard error of Maths by RACE - saves the output as a tibble data table called my_sum\n\nmy_sum <- exam %>%\n  group_by(RACE) %>%\n  summarise(n = n(),\n            mean = mean(MATHS),\n            sd = sd(MATHS)) %>%\n  mutate(se = sd/sqrt(n-1))\n\nknitr::kable(head(my_sum),\n             format = \"html\")\n\n\n\n \n  \n    RACE \n    n \n    mean \n    sd \n    se \n  \n \n\n  \n    Chinese \n    193 \n    76.50777 \n    15.69040 \n    1.132357 \n  \n  \n    Indian \n    12 \n    60.66667 \n    23.35237 \n    7.041005 \n  \n  \n    Malay \n    108 \n    57.44444 \n    21.13478 \n    2.043177 \n  \n  \n    Others \n    9 \n    69.66667 \n    10.72381 \n    3.791438 \n  \n\n\n\n\n\nThe code chunk below is used to reveal the standard error of mean maths score by race.\n\nggplot(my_sum) +\n  geom_errorbar(aes(x = RACE,\n                    ymin = mean-se,\n                    ymax = mean+se),\n                width = 0.2,\n                colour = \"black\",\n                alpha = 0.9,\n                size = 0.5) +\n  geom_point(aes(x = RACE,\n                 y = mean),\n             stat = \"identity\",\n             color = \"red\",\n             size = 1.5,\n             alpha = 1) +\n  ggtitle(\"Standard error of mean maths score by race\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\nggdist package\n\nggdist is a package that provides a flexible set of ggplot2 geoms and stats designed especially for visualizing distributions and uncertainty\ndesigned for both frequentist and Bayesian uncertainty visualization, taking the view that uncertainty visualization can be unified through the perspective of distribution visualization\nfor frequentist models, one visualizes confidence distributions or bootstrap distribution\nfor Bayesian models, one visualizes probability distributions\n\n\nggdist methods\nIn the code chunk below, stat_pointinterval() of ggdist is used to build a visual for displaying distribution of maths score by race.\n\nexam %>%\n  ggplot(aes(x = RACE,\n             y = MATHS)) +\n  stat_pointinterval(.width = 0.95,\n                     .point = median,\n                     .interval = qi) +\n  labs(title = \"Visualizing confidence intervals of mean math score\",\n       subtitle = \"Mean Point + Multiple-interval plot\")\n\nWarning in layer_slabinterval(data = data, mapping = mapping, stat =\nStatPointinterval, : Ignoring unknown parameters: `.point` and `.interval`\n\n\n\n\n\nIn the code chunk below, stat_gradientinterval() of ggdist is used to build a visual for displaying distribution of maths score by race.\n\nexam %>%\n  ggplot(aes(x = RACE,\n             y = MATHS)) +\n  stat_gradientinterval(fill = \"skyblue\",\n                        show.legend = TRUE) +\n  labs(title = \"Visualizing confidence intervals of mean math score\",\n       subtitle = \"Gradient + Interval plot\")\n\nWarning: fill_type = \"gradient\" is not supported by the current graphics device.\n - Falling back to fill_type = \"segments\".\n - If you believe your current graphics device *does* support\n   fill_type = \"gradient\" but auto-detection failed, set that option\n   explicitly and consider reporting a bug.\n - See help(\"geom_slabinterval\") for more information.\n\n\n\n\n\n\n\n\nHypothetical Outcome Plots\nStep 1: Installing the ungeviz package:\n\ndevtools::install_github(\"wilkelab/ungeviz\")\n\nSkipping install of 'ungeviz' from a github remote, the SHA1 (aeae12b0) has not changed since last install.\n  Use `force = TRUE` to force installation\n\n\nStep 2: Launch the application in R:\n\nlibrary(ungeviz)\n\nggplot(data = exam,\n       aes(x = factor(RACE),\n           y = MATHS)) +\n  geom_point(position = position_jitter(height = 0.3, width = 0.05),\n             size = 0.4,\n             color = \"#0072B2\",\n             alpha = 1/2) +\n  geom_hpline(data = sampler(25, group = RACE),\n              height = 0.6,\n              color = \"#D55E00\") +\n  theme_bw() +\n  transition_states(.draw, 1, 3)\n\nWarning in geom_hpline(data = sampler(25, group = RACE), height = 0.6, color =\n\"#D55E00\"): Ignoring unknown parameters: `height`\n\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead."
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex04/Hands_on_Ex04c.html",
    "href": "Hands_on_Ex/Hands_on_Ex04/Hands_on_Ex04c.html",
    "title": "Hands-on Exercise 4: Funnel Plots",
    "section": "",
    "text": "Funnel plot is a specially designed data visualization for conducting unbiased comparison between outlets, stores or business entities. By the end of this exercise, we will gain experience on\n\nplotting funnel plots by using funnelPlotR package\nplotting static funnel plot by using ggplot2 package\nplotting interactive funnel plot by using both plotly R and ggplot2 packages"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex04/Hands_on_Ex04c.html#makeover-1",
    "href": "Hands_on_Ex/Hands_on_Ex04/Hands_on_Ex04c.html#makeover-1",
    "title": "Hands-on Exercise 4: Funnel Plots",
    "section": "Makeover 1",
    "text": "Makeover 1\nThe code chunk below plots a funnel plot:\n\nfunnel_plot(numerator = covid19$Death,\n            denominator = covid19$Positive,\n            group = covid19$`Sub-district`,\n            data_type = \"PR\",\n            xrange = c(0, 6500),\n            yrange = c(0, 0.05))\n\nWarning: The `xrange` argument deprecated; please use the `x_range` argument\ninstead. For more options, see the help: `?funnel_plot`\n\n\nWarning: The `yrange` argument deprecated; please use the `y_range` argument\ninstead. For more options, see the help: `?funnel_plot`\n\n\n\n\n\nA funnel plot object with 267 points of which 7 are outliers. \nPlot is adjusted for overdispersion. \n\n\nThings to learn from the code chunk above:\n\ndata_type argument is used to change from default “SR” to “PR” (proportions)\nxrange and yrange are used to set the range of x-axis and y-axis"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex04/Hands_on_Ex04c.html#makeover-2",
    "href": "Hands_on_Ex/Hands_on_Ex04/Hands_on_Ex04c.html#makeover-2",
    "title": "Hands-on Exercise 4: Funnel Plots",
    "section": "Makeover 2",
    "text": "Makeover 2\nThe code chunk below plots a funnel plot:\n\nfunnel_plot(numerator = covid19$Death,\n            denominator = covid19$Positive,\n            group = covid19$`Sub-district`,\n            data_type = \"PR\",\n            xrange = c(0, 6500),\n            yrange = c(0, 0.05),\n            label = NA,\n            title = \"Cumulative COVID-19 Fatality Rate by Cumulative Total Number of COVID-19 Positive Cases\",\n            x_label = \"Cumulative COVID-19 Positive Cases\",\n            y_label = \"Cumulative Fatality Rate\")\n\nWarning: The `xrange` argument deprecated; please use the `x_range` argument\ninstead. For more options, see the help: `?funnel_plot`\n\n\nWarning: The `yrange` argument deprecated; please use the `y_range` argument\ninstead. For more options, see the help: `?funnel_plot`\n\n\n\n\n\nA funnel plot object with 267 points of which 7 are outliers. \nPlot is adjusted for overdispersion. \n\n\nThings to learn from the code chunk above:\n\nlabel = NA argument is to remove the default label outliers feature\ntitle argument is used to add the plot title\nx_label and y_label arguments are used to add/edit x-axis and y-axis titles"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex05/Hands_on_Ex05a.html",
    "href": "Hands_on_Ex/Hands_on_Ex05/Hands_on_Ex05a.html",
    "title": "Hands-on Exercise 5: Ternary Plots",
    "section": "",
    "text": "Ternary Plots are a way of displaying the distribution and variability of three-part compositional data. For example, the proportion of aged, economy active and young population, or sand, silt and clay in solid. It’s display is a triangle with sides scaled from 0 to 1. Each side represents one of the three components. A point is plotted so that a line drawn perpendicular from the point to each leg of the triangle intersect at the component values of the point.\nIn this hands-on exercise, we will learn how to build a ternary plot programmatically using R for visualizing and analyzing the population structure of Singapore.\nThe hands-on exercise will consist of four steps:\n\nInstall and launch tidyverse and ggtern packages\nDerive three new measures using mutate() function of dplyr package\nBuild a static ternary plot using ggtern() function of ggtern package\nBuild an interactive ternary plot using plot-ly() function of Plotly R package\n\n\nInstalling & Launching R Packages\nTwo main R packages will be used in this hands-on exercise:\n\nggtern, a ggplot extension specially designed to plot ternary diagrams\nPlotly R, an R package for creating interactive web-based graphs via plotly’s JavaScript graphing library, plotly.js\n\nWe will also need to ensure that selected tidyverse family packages are also installed and loaded.\nThe code chunk below loads the necessary packages:\n\npacman::p_load(ggtern, plotly, tidyverse)\n\n\n\nData Preparation\nFor this hands-on exercise, we will use the following dataset:\n\npop_data <- read_csv(\"data/respopagsex2000to2018_tidy.csv\")\n\nRows: 108126 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): PA, SZ, AG\ndbl (2): Year, Population\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nNext, we will use the mutate() function of dplyr package to derive three new measures, namely young, active and old.\n\nagpop_mutated <- pop_data %>%\n  mutate('Year' = as.character(Year)) %>%\n  pivot_wider(names_from = AG,\n              values_from = Population) %>%\n  mutate(YOUNG = rowSums(.[4:8])) %>%\n  mutate(ACTIVE = rowSums(.[9:16])) %>%\n  mutate(OLD = rowSums(.[17:21])) %>%\n  mutate(TOTAL = rowSums(.[22:24])) %>%\n  filter(Year == 2018) %>%\n  filter(TOTAL > 0)\n\n\n\nStatic Ternary Diagram\nWith the use of ggtern() function of ggtern package, we will create a simple ternary plot.\n\nggtern(data = agpop_mutated,\n       aes(x = YOUNG,\n           y = ACTIVE,\n           z = OLD)) +\n  geom_point() +\n  labs(title = \"Population Structure, 2018\") +\n  theme_rgbw()\n\n\n\n\n\n\nInteractive Ternary Diagram\nThe code chunk below will plot an interactive ternary plot using plot_ly() function of Plotly R.\n\nlabel <- function(txt) {\n  list(text = txt,\n       x = 0.1, y = 1,\n       ax = 0, ay = 0,\n       xref = \"paper\", yref = \"paper\",\n       align = \"center\",\n       font = list(family = \"serif\",\n                   size = 15,\n                   color = \"white\"),\n       bgcolor = \"#b3b3b3\",\n       bordercolor = \"black\",\n       borderwidth = 2)\n}\n\naxis <- function(txt) {\n  list(title = txt,\n       tickformat = \".0%\",\n       tickfont = list(size = 10))\n}\n\nternaryAxes <- list(aaxis = axis(\"Young\"),\n                    baxis = axis(\"Active\"),\n                    caxis = axis(\"Old\"))\n\nplot_ly(agpop_mutated,\n        a = ~YOUNG,\n        b = ~ACTIVE,\n        c = ~OLD,\n        color = I(\"black\"),\n        type = \"scatterternary\") %>%\n  layout(annotations = label(\"Ternary Markers\"),\n         ternary = ternaryAxes)\n\nNo scatterternary mode specifed:\n  Setting the mode to markers\n  Read more about this attribute -> https://plotly.com/r/reference/#scatter-mode"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex05/Hands_on_Ex05b.html",
    "href": "Hands_on_Ex/Hands_on_Ex05/Hands_on_Ex05b.html",
    "title": "Hands-on Exercise 5: Correlation Matrices",
    "section": "",
    "text": "Correlation coefficient is a popular statistic that is used to measure the type of strength of the relationship between two variables. The values of a correlation coefficient ranges between -1.0 and 1.0. A correlation coefficient of 1 shows a perfect linear relationship between the two variables, while a -1.0 shows a perfect inverse relationship between the two variables. A correlation coefficient of 0.0 shows no linear relationship between the two variables.\nWhen multivariate data are used, the correlation coefficients of the pair comparisons are displayed in a table form known as correlation matrix or scatterplot matrix.\nThere are three broad reasons for computing a correlation matrix:\n\nto reveal the relationship between high-dimensional variables pair-wisely\nto input into other analyses\nas a diagnostic when checking other analyses\n\nWhen the data is large, both in terms of the number of observations and the number of variables, corrgram tends to be used to visually explore and analyse the structure and the patterns of relations among variables. It is designed based on two main schemes:\n\nrendering the value of a correlation to depict its sign and magnitude\nreordering the variables in a correlation matrix so that “similar” variables are positioned adjacently, facilitating perception\n\nIn this hands-on exercise, we will learn how to plot data visualization for correlation matrix in R.\n\nInstalling & Launching R Packages\nWe will use the code chunk below to install and launch the necessary packages.\n\npacman::p_load(corrplot, ggstatsplot, tidyverse)\n\n\n\nImporting & Preparing Dataset\nLet’s load the dataset that we will be using for this exercise.\n\nwine <- read.csv(\"data/wine_quality.csv\")\n\n\n\nCorrelation Matrix: pairs()\nThere are few ways to build a scatterplot matrix in R. In this section, we will be creating a scatterplot matrix by using the pairs function of R Graphics.\n\nBasic Correlation Matrix\nThe code chunk below will create a 11 by 11 matrix of the Wine Quality dataset.\n\npairs(wine[,1:11])\n\n\n\n\nThe required input of pairs() can be a matrix or a dataframe. As for the code chunk used, which is relatively simple, uses the default pairs function. We can specify the columns to be used to build the scatterplot matrix.\n\n\nUpper & Lower Corners\nThe pairs function of R Graphics provides many customization arguments. For example, it is a common practice to show either the upper half or lower half of the correlation matrix instead of showing both. This is because a correlation matrix is symmetric.\nTo show the lower half of the correlation matrix, the upper.panel argument will be used as shown in the code chunk below.\n\npairs(wine[,2:12],\n      upper.panel = NULL)\n\n\n\n\nSimilarly, we can display the upper half of the correlation matrix by using the code chunk below.\n\npairs(wine[,2:12],\n      lower.panel = NULL)\n\n\n\n\n\n\nIncluding Correlation Coefficients\nTo show the correlation coefficient of each pair of variables instead of a scatterplot, panel.cor function will be used. This will also show higher correlations in a larger font.\n\npanel.cor <- function(x, y, digits=2, prefix=\"\", cex.cor, ...) {\n  usr <- par(\"usr\")\n  on.exit(par(usr))\n  par(usr = c(0, 1, 0, 1))\n  r <- abs(cor(x, y, use = \"complete.obs\"))\n  txt <- format(c(r, 0.123456789), digits = digits)[1]\n  txt <- paste(prefix, txt, sep = \"\")\n  if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)\n  text(0.5, 0.5, txt, cex = cex.cor * (1 + r) / 2)\n}\n\npairs(wine[,2:12], \n      upper.panel = panel.cor)\n\n\n\n\n\n\n\nCorrelation Matrix: ggcormat()\nOne of the major limitation of the correlation matrix is that the scatter plots appear very cluttered when the number of observations is relatively large (more than 500 observations). To overcome this problem, Corrgram data visualization technique will be used.\nThere are three R packages that provide functions to plot corrgram:\n\ncorrgram\nellipse\ncorrplot\n\nOn top of that, R packages like ggstatsplot package also provide functions for building corrgram.\nIn this section, we will visualize correlation matrix by using ggcorrmat() of ggstatsplot.\n\nBasic Plot\nOne of the advantage of using ggcorrmat() over other methods is that it has the ability to provide a comprehensive and yet professional statistical report as shown in the figure below.\n\nggstatsplot::ggcorrmat(data = wine,\n                       cor.vars = 1:11,\n                       ggcorrplot.args = list(outline.color = \"black\",\n                                              hc.order = TRUE,\n                                              tl.cex = 10),\n                       title = \"Correlogram for wine dataset\",\n                       subtitle = \"Four pairs are not significant at p < 0.05\")\n\n\n\n\nThings to learn about the code chunk above:\n\ncor.vars argument is used to compute the correlation matrix needed to build the corrgram\nggcorrplot.args argument provides additional (mostly aesthetic) arguments that will be passed to ggcorrplot:::ggcorrplot function\nthe ggcorrplot.args argument should avoid any of the following arguments since they are already internally being used: corr, method, p.mat, sig.level, ggtheme, colors, lab, pch, legend.title, digits\n\nThe following code chunk can be used to control specific components of the plot, such as the font size of the x-axis, y-axis and the statistical report.\n\nggplot.component = list(theme(text = element_text(size = 5),\n                              axis.text.x = element_text(size = 8),\n                              axis.text.y = element_text(size = 8)))\n\n\n\nMultiple Plots\nSince ggstatsplot is an extension of ggplot2, it also supports faceting. However, the feature is not available in ggcorrmat(), but it available in the grouped_ggcorrmat() of ggstatsplot.\n\ngrouped_ggcorrmat(data = wine,\n                  cor.vars = 1:11,\n                  grouping.var = type,\n                  type = \"robust\",\n                  p.adjust.method = \"holm\",\n                  plotgrid.args = list(ncol = 2),\n                  ggcorrplot.args = list(outline.color = \"black\",\n                                         hc.order = TRUE,\n                                         tl.cex = 10),\n                  annotation.args = list(tag_levels = \"a\",\n                                         title = \"Correlogram for wine dataset\",\n                                         subtitle = \"The measures are: alcohol, sulphates, fixed acidity, citric acid, chlorides, residual sugar, density, free sulfur dioxide and volatile acidity\",\n                                         caption = \"Dataset: UCI Machine Learning Repository\"))\n\n\n\n\nThings to learn from the code chunk above:\n\nto build a facet plot, the only argument needed is grouping.var\nbehind group_ggcorrmat(), patchwork package is used to create the multiplot\nplotgrid.args argument provides a list of additional arguments passed to patchwork::wrap_plots, except for the guides argument which is already separately specified earlier\nlikewise, the annotation.args argument is calling plot annotation argument of patchwork package\n\n\n\n\nCorrelation Matrix: corrplot\nBefore we can plot a corrgram using corrplot(), we need to compute the correlation matrix of wine data frame. In the code chunk below, cor() of R Stats is used to compute the correlation matrix of wine dataframe.\n\nwine.cor <- cor(wine[,1:11])\n\nNext, corrplot() will be used to plot the corrgram by using all the default settings as shown in the code chunk below:\n\ncorrplot(wine.cor)\n\n\n\n\nFrom the above plot, notice that the default visual object used to plot the corrgram is circle, and the default layout of the corrgram is a symmetric matrix. Also, the default colour scheme is diverging bllue-red. Blue colours are used to represent pair variables with a positive correlation coefficient while red colours are used to represent pair variables with negative correlation coefficient. The intensity of the colour, aka the saturation, is used to represent the strength of the correlation coefficient. Darker colours indicate relatively stronger linear relationship between the paired variables. On the other hand, lighter colours indicate relatively weaker linear relationships.\n\nVisual Geometrics\nIn the corrplot package, there are seven visual geometrics (parameter methods) that can be used to encode the attribute values. They are:\n\ncircle\nsquare\nellipse\nnumber\nshade\ncolor\npie\n\nAs shown in the previous section, the default visual geometric of corrplot matrix is circle. However, this default setting can be changed by using the method argument as shown in the code chunk below.\n\ncorrplot(wine.cor,\n         method = \"ellipse\")\n\n\n\n\n\n\nLayouts\ncorrplot() supports three layout types:\n\nfull\nupper\nlower\n\nThe default is full, which means it will display the full matrix. The default settings can be changed by using the type argument of corrplot()\n\ncorrplot(wine.cor,\n         method = \"ellipse\",\n         type = \"lower\")\n\n\n\n\nThe default layout of the corrgram can be further customized. For example, arguments diag and tl.col are used to turn off the diagonal cells, and to change the axis text label colour to black colour respectively, as shown in the code chunk below.\n\ncorrplot(wine.cor,\n         method = \"ellipse\",\n         type = \"lower\",\n         diag = FALSE,\n         tl.col = \"black\")\n\n\n\n\n\n\nMixed Layouts\nWith corrplot package, it is possible to design corrgram with mixed visual matrix of one half, and numerical matrix on the other half. In order to create a coorgram with mixed layout, the corrplot.mixed(), a wrapped function for mixed visualization stype, will be used.\n\ncorrplot.mixed(wine.cor,\n               lower = \"ellipse\",\n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n\n\n\n\nNotice that the argument lower and upper are used to define the visualization method used. In this case, ellipse is used to map the lower half of the corrgram, while the numerical matrix is used to map the upper half of the corrgram. The tl.pos is used to specify the placement of the axis labels. Lastly, the diag argument is used to specify the glyph on the prinicpal diagonal of the corrgram.\n\n\ncorrgram with significant test\nIn statistical analysis, we are also interested to know which pair of variables has a correlation coefficient that is statistically significant. The plot below shows a corrgram that is combined with the significant test. The corrgram reveals that not all correlation pairs are statistically significant.\nWith corrplot package, we can use the cor.mtest() to compute the p-values and confidence interval for each pair of the variables.\n\nwine.sig = cor.mtest(wine.cor,\n                     conf.level = .95)\n\nWe can then use the p.mat argument of corrplot function as shown in the code chunk below.\n\ncorrplot(wine.cor,\n         method = \"number\",\n         type = \"lower\",\n         diag = FALSE,\n         tl.col = \"black\",\n         tl.srt = 45,\n         p.mat = wine.sig$p,\n         sig.level = .05)\n\n\n\n\n\n\nReordering a corrgram\nMatrix reorder is very important for mining the hidden structure and pattern in a corrgram. By default, the order of attributes of a corrgram is sorted according to the correlation matrix. The default setting can be overwritten by using the order argument of corrplot(). Currently, corrplot package supports four sorting methods:\n\nAOE is for the angular order of the eigenvectors\nFPC for the first principal component order\nhclust for hierarchical cluster order and hclust.method for the agglomeration method to be used\nalphabet for the alphabetical order\n\n\ncorrplot.mixed(wine.cor,\n               lower = \"ellipse\",\n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               order = \"AOE\",\n               tl.col = \"black\")\n\n\n\n\nIf we are using hclust.corrplot(), we can draw rectangles around the corrgram based on the results of the hierarchical clustering.\n\ncorrplot(wine.cor,\n         method = \"ellipse\",\n         tl.pos = \"lt\",\n         tl.col = \"black\",\n         order = \"hclust\",\n         hclust.method = \"ward.D\",\n         addrect = 3)"
  },
  {
    "objectID": "Hands_on_Ex/Hands_on_Ex05/Hands_on_Ex05c.html",
    "href": "Hands_on_Ex/Hands_on_Ex05/Hands_on_Ex05c.html",
    "title": "Hands-on Exercise 5: Heatmap",
    "section": "",
    "text": "Overview\nHeatmaps visualize data through variation in colouring. When applied to a tabular format, heatmaps are useful for cross-examining multivariate data through placing variables in the columns and observations in rows and colouring the cells within the table. Heatmaps are good for showing variance across multiple variables, revealing any patterns, displaying whether any variables are similar to each other, and for detecting if any correlations exist in-between them.\nIn this hands-on exercise, we will use R to plot static and interactive heatmaps for visualizing and analyzing multivariate data.\n\n\nInstalling & Launching R Packages\nThe code chunk below will install and launch the necessary packages in R.\n\npacman::p_load(seriation, dendextend, heatmaply, tidyverse)\n\n\n\nDataset\nWe will be using the following dataset:\n\nwh <- read_csv(\"data/WHData-2018.csv\")\n\nNext, we need to change the rows by country name instead of row numbers by using the code chunk below:\n\nrow.names(wh) <- wh$Country\n\nNotice that the row number has now been replaced into the country name.\nThe data was loaded into a dataframe, but it has to be a data matrix in order to build a heatmap. The code chunk below will be used to transform the wh dataframe into a data matrix.\n\nwh_matrix <- data.matrix(wh)\n\n\n\nStatic Heatmap\nThere are many R packages and functions that can be used to draw static heatmaps. They are:\n\nheatmap() of R stats package, which draws a simple heatmap\nheatmap.2() of gplot R package, which draws an enhanced heatmap\npheatmap() of pheatmap R package, which draws a pretty heatmap and provides more control to change the appearance of heatmaps\nComplexHeatmap package of R package, which draws, annotates and arranges complex heatmaps\nsuperheat package which is a system for generating extendable and customizable heatmaps for exploring complex datasets, including big data and data with multiple data types\n\nIn this section, we will be plotting static heatmaps using heatmap() of R Stats package.\n\nheatmap()\nIn the following code chunk, we will plot a heatmap by using heatmap() of Base Stats:\n\nwh_heatmap <- heatmap(wh_matrix,\n                      Rowv = NA,\n                      Colv = NA)\n\n\n\n\nBy default, heatmap() plots a cluster heatmap. The arguments Rowv and Colv are used to switch off the option of plotting the row and column dendrograms.\nTo plot a cluster heatmap, we have to use the default settings as shown in the code chunk below:\n\nwh_heatmap <- heatmap(wh_matrix)\n\n\n\n\nThe orer of both rows and columns are different when compared to the native wh_matrix. This is because the heatmap does a reordering using clusterization. It calculates the distance between each pair of rows and columns and tries to order them by similarity. Moreover, the corresponding dendrograms are provided beside the heatmap.\nHere, the red cells denote small values. This heatmap is not really informative is it? Thus, we need to normalize this matrix. This is done using the scale argument. This can be applied to rows or to columns based on our needs. The code chunk below normalizes the matrix column-wise:\n\nwh_heatmap <- heatmap(wh_matrix,\n                      scale = \"column\",\n                      cexRow = 0.6,\n                      cexCol = 0.8,\n                      margins = c(10, 4))\n\n\n\n\nNotice that the values are scaled now. Also, note that the margins argument is used to ensure that the entire x-axis labels are displayed completely, and cexRow and cexCol arguments are used to dedine the font size used for y-axis and x-axis labels separately.\n\n\n\nInteractive Heatmap\nheatmaply is an R package for building interactive cluster heatmaps that can be shared online as a standalone HTML file. In this section, we will be using heatmaply to design an interactive cluster heatmap while using wh_matrix as the input data.\n\nheatmaply(wh_matrix[, -c(1, 2, 4, 5)])\n\n\n\n\n\nNote the following:\n\ndifferent from heatmap(), as heatmaply() has the default horizontal dendrogram placed on the left hand side of the heatmap\ntext label is placed on the right hand side of the heatmap\nwhen the x-axis marker labels are too long, they will be rotated by 135 degrees from the north\n\nWhen analyzing multivariate data set, it is very common that the variables in the datasets include values that reflect the different types of measurement. In general, these variables’ values have their own range. In order to ensure that all the variables have comparable values, data transformation is commonly used before clustering.\nThe three main data transformation methods supported by heatmaply() are:\n\nscale\nnormalize\npercentize\n\n\nScaling Method\n\nScaling refers to subtracting the mean and dividing it by the standard deviation\nWhen all variables come from or are assumed to come from some normal distribution, then scaling would bring them all closer to the standard normal distribution\nIn such a case, each value would reflect the distance from the mean in units of standard deviation\nThe scale argument in heatmaply() supports column and row scaling\n\n\nheatmaply(wh_matrix[, -c(1, 2, 4, 5)],\n          scale = \"column\")\n\n\n\n\n\n\n\nNormalizing Method\n\nWhen variables in the data come from possibly different and non-normal distributions, the normalize function can be used to bring data to the 0 to 1 scale by subtracting the minimum and dividing by the maximum of all observations\nThis preserves the shape of each variable’s distribution while making them easily comparable on the same scale\nDifferent from scaling, the normalize method is performed on the input dataset\n\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]))\n\n\n\n\n\n\n\nPercentize Method\n\nThis is similar to ranking the variables, but instead of keeping the rank values, we divide them by the maximal rank\nThis is done by using the ecdf of the variables on their own values, bringing each value to its empirical percentile\nThe benefit of the percentize function is that each value has a relatively clear interpretation, it is the percent of observations that got that value or below it\nSimilar to normalize method, the percentize method is also performed on the input dataset\n\n\nheatmaply(percentize(wh_matrix[, -c(1, 2, 4, 5)]))\n\n\n\n\n\n\n\n\nClustering\nheatmaply supports a variety of hierarchical clustering algorithms. The main arguments provided are:\n\ndistfun: function used to compute the distance (dissimilarity) between both rows and columns, defaults to dist, options are pearson, spearman and kendall\nhclustfun: function used to compute the hierarchical clustering when Rowv or Colv are not dendrograms, defaults to hclust\ndist_method: default is NULL, which results in euclidean to be used, can accept alternative character strings indicating the method to be passed to distfun\nhclust_method, default is NULL, which results in complete method to be used, can accept alternative character strings indicating the method to be passed to hclustfun\n\nIn general, a clustering model can be calibrated either manually or statistically.\n\nManual Approach\nIn the code chunk below, the heatmap is plotted by using hierarchical clustering algorithm with euclidean distance and ward.D method.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\")\n\n\n\n\n\n\n\nStatistical Approach\nIn order to determine the best clustering method and number of clusters, the dend_expend() and find_k() functions of dendextend package will be used. First, the dend_expend() function will be used to determine the recommended clustering method to be used.\n\nwh_d <- dist(normalize(wh_matrix[, -c(1, 2, 4, 5)]), \n             method = \"euclidean\")\ndend_expend(wh_d)[[3]]\n\n  dist_methods hclust_methods     optim\n1      unknown         ward.D 0.6137851\n2      unknown        ward.D2 0.6289186\n3      unknown         single 0.4774362\n4      unknown       complete 0.6434009\n5      unknown        average 0.6701688\n6      unknown       mcquitty 0.5020102\n7      unknown         median 0.5901833\n8      unknown       centroid 0.6338734\n\n\nThe output table shows that average method should be used because it gave the highest optimum value.\nNext, we will use the find_k() function to determine the optimal number of clusters.\n\nwh_clust <- hclust(wh_d, \n                   method = \"average\")\nnum_k <- find_k(wh_clust)\nplot(num_k)\n\n\n\n\nThe plot shows that k = 3 will be good.\nWith reference to the statistical analysis results, we can prepare the code chunk as shown below.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          dist_method = \"euclidean\",\n          hclust_method = \"average\",\n          k_row = 3)\n\n\n\n\n\n\n\n\nSeriation\nOne of the problems with hierarchical clustering is that it doesn’t actually place the rows in a definite order, it merely constraints the space of possible orderings. heatmaply uses the seriation package to find an optimal ordering of rows and columns.\nOptimal Leaf Ordering (OLO) is a seriation algorithm. This algorithm starts with the output of an agglomerative clustering algorithm and produces a unique ordering, one that flips the various branches of the dendrogram around so as to minimize the sum of dissimilarities between adjacent leaves.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"OLO\")\n\n\n\n\n\nThe default option is OLO. Another option would be GW - Gruvaeus and Wainer, which aims for the same goal but uses a potentially faster heuristic.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"GW\")\n\n\n\n\n\nThe option mean gives the output we would get by default from the heatmap function in other packages.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"mean\")\n\n\n\n\n\nThe option none gives us the dendrograms without any rotation that is based on the data matrix.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"none\")\n\n\n\n\n\n\n\nColour Palettes\nThe default colour palette used by heatmaply is viridis. heatmaply users, however, can use other colour palettes in order to improve the aestheticness and visual friendliness of the heatmap.\nIn the code chunk below, the Blues colour palette of rColorBrewer is used:\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"none\",\n          colors = Blues)\n\n\n\n\n\n\n\nAdditional Arguments\nBesides providing a wide collection of arguments for meeting the statistical analysis needs, heatmaply also provides many plotting features to ensure that a cartographic quality heatmap can be produced.\nIn the code chunk below, the following arguments are used:\n\nk_row is used to produce 5 groups\nmargins is used to change the top margin to 60 and row margin to 200\nfontsize_row and fonstize_col are used to change the font size for row and column labels to 4\nmain is used to write the main title of the plot\nxlab and ylab are used to write the x-axis and y-acis labels respectively\n\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          Colv = NA,\n          seriate = \"none\",\n          colors = Blues,\n          k_row = 5,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main = \"World Happiness Score and Variables by Country, 2018 \\nDataTransformation using Normalise Method\",\n          xlab = \"World Happiness Indicators\",\n          ylab = \"World Countries\"\n          )"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS608-VAA",
    "section": "",
    "text": "Welcome to ISSS608 Visual Analytics and Applications. In this website, you will find my coursework prepared for this course."
  },
  {
    "objectID": "In_Class_Ex/In_Class_Ex03/In_Class_Ex03.html",
    "href": "In_Class_Ex/In_Class_Ex03/In_Class_Ex03.html",
    "title": "In-Class Exercise 3",
    "section": "",
    "text": "Installing and loading R packages\nTwo packages will be installed and loaded. They are: tidyverse and ggiraph,\n\npacman::p_load(ggiraph, tidyverse)\n\nImporting data\n\nexam_data <- read_csv(\"data/Exam_data.csv\")\n\nWithout interactivity:\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_dotplot(dotsize = 0.5)\n\n\n\n\nWith interactivity:\n\ntooltip_css <- \"background-color:white; font-style:bold; color:black;\"\n\np <- ggplot(data = exam_data,\n            aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(tooltip = ID),\n                           stackgroups = TRUE,\n                           binwidth = 1,\n                           method =  \"histodot\") +\n  scale_y_continuous(NULL,\n                     breaks = NULL)\n\ngirafe(ggobj = p,\n       width_svg = 6,\n       height_svg = 6*0.618,\n       options = list(opts_tooltip(css = tooltip_css)))"
  },
  {
    "objectID": "In_Class_Ex/In_Class_Ex04/In_Class_Ex04.html",
    "href": "In_Class_Ex/In_Class_Ex04/In_Class_Ex04.html",
    "title": "In-Class Exercise 4",
    "section": "",
    "text": "The code chunk below installed the necessary R packages.\n\npacman::p_load(plotly, DT, patchwork, tidyverse, ggstatsplot, ggside, readxl, performance, parameters, see)\n\nThe code chunk below loads the Exam_data.csv file.\n\nexam_data <- read_csv(\"data/Exam_data.csv\")\n\nRows: 322 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): ID, CLASS, GENDER, RACE\ndbl (3): ENGLISH, MATHS, SCIENCE\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThe code chunk below creates an interactive visualization using plot_ly().\n\nplot_ly(data = exam_data,\n        x = ~ENGLISH,\n        y = ~MATHS,\n        color = ~RACE)\n\nNo trace type specified:\n  Based on info supplied, a 'scatter' trace seems appropriate.\n  Read more about this trace type -> https://plotly.com/r/reference/#scatter\n\n\nNo scatter mode specifed:\n  Setting the mode to markers\n  Read more about this attribute -> https://plotly.com/r/reference/#scatter-mode\n\n\n\n\n\n\nThe code chunk below creates an interactive scatterplot using ggplotly().\n\np <- ggplot(data = exam_data,\n            aes(x = MATHS,\n                y = ENGLISH)) +\n  geom_point(dotsize = 1) +\n  coord_cartesian(xlim = c(0, 100),\n                  ylim = c(0, 100))\n\nWarning in geom_point(dotsize = 1): Ignoring unknown parameters: `dotsize`\n\nggplotly(p)\n\n\n\n\n\nThe code chunk below is used to build a visual for the two-sample mean test of Maths scores by Gender.\n\nggbetweenstats(data = exam_data,\n               x = GENDER,\n               y = MATHS,\n               type = \"np\",\n               messages = FALSE)\n\n\n\n\nIn the code chunk below, ggscatterstats() is used to build a visual for Significant Tesst of Correlation between the Maths and English scores.\n\nggscatterstats(data = exam_data,\n               x = MATHS,\n               y = ENGLISH,\n               marginal = TRUE)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nThe code chunk below, let’s import the data worksheet of ToyottaCorolla.xls into R.\n\ncar_resale <- read_xls(\"data/ToyotaCorolla.xls\",\n                       \"data\")\ncar_resale\n\n# A tibble: 1,436 × 38\n      Id Model       Price Age_0…¹ Mfg_M…² Mfg_Y…³     KM Quart…⁴ Weight Guara…⁵\n   <dbl> <chr>       <dbl>   <dbl>   <dbl>   <dbl>  <dbl>   <dbl>  <dbl>   <dbl>\n 1    81 TOYOTA Cor… 18950      25       8    2002  20019     100   1180       3\n 2     1 TOYOTA Cor… 13500      23      10    2002  46986     210   1165       3\n 3     2 TOYOTA Cor… 13750      23      10    2002  72937     210   1165       3\n 4     3  TOYOTA Co… 13950      24       9    2002  41711     210   1165       3\n 5     4 TOYOTA Cor… 14950      26       7    2002  48000     210   1165       3\n 6     5 TOYOTA Cor… 13750      30       3    2002  38500     210   1170       3\n 7     6 TOYOTA Cor… 12950      32       1    2002  61000     210   1170       3\n 8     7  TOYOTA Co… 16900      27       6    2002  94612     210   1245       3\n 9     8 TOYOTA Cor… 18600      30       3    2002  75889     210   1245       3\n10    44 TOYOTA Cor… 16950      27       6    2002 110404     234   1255       3\n# … with 1,426 more rows, 28 more variables: HP_Bin <chr>, CC_bin <chr>,\n#   Doors <dbl>, Gears <dbl>, Cylinders <dbl>, Fuel_Type <chr>, Color <chr>,\n#   Met_Color <dbl>, Automatic <dbl>, Mfr_Guarantee <dbl>,\n#   BOVAG_Guarantee <dbl>, ABS <dbl>, Airbag_1 <dbl>, Airbag_2 <dbl>,\n#   Airco <dbl>, Automatic_airco <dbl>, Boardcomputer <dbl>, CD_Player <dbl>,\n#   Central_Lock <dbl>, Powered_Windows <dbl>, Power_Steering <dbl>,\n#   Radio <dbl>, Mistlamps <dbl>, Sport_Model <dbl>, Backseat_Divider <dbl>, …\n\n\nThe code chunk below is used to build a multiple linear regression model by using lm() of Base Stas of R.\n\nmodel <- lm(Price ~ Age_08_04 + Mfg_Year + KM + Weight + Guarantee_Period,\n            data = car_resale)\nmodel\n\n\nCall:\nlm(formula = Price ~ Age_08_04 + Mfg_Year + KM + Weight + Guarantee_Period, \n    data = car_resale)\n\nCoefficients:\n     (Intercept)         Age_08_04          Mfg_Year                KM  \n      -2.637e+06        -1.409e+01         1.315e+03        -2.323e-02  \n          Weight  Guarantee_Period  \n       1.903e+01         2.770e+01  \n\n\nThe code chunk below checks for collinearity.\n\ncheck_collinearity(model)\n\n# Check for Multicollinearity\n\nLow Correlation\n\n             Term   VIF     VIF 95% CI Increased SE Tolerance Tolerance 95% CI\n Guarantee_Period  1.04   [1.01, 1.17]         1.02      0.97     [0.86, 0.99]\n        Age_08_04 31.07 [28.08, 34.38]         5.57      0.03     [0.03, 0.04]\n         Mfg_Year 31.16 [28.16, 34.48]         5.58      0.03     [0.03, 0.04]\n\nHigh Correlation\n\n   Term  VIF   VIF 95% CI Increased SE Tolerance Tolerance 95% CI\n     KM 1.46 [1.37, 1.57]         1.21      0.68     [0.64, 0.73]\n Weight 1.41 [1.32, 1.51]         1.19      0.71     [0.66, 0.76]\n\n\nWe can also plot this collinearity.\n\ncheck_c <- check_collinearity(model)\nplot(check_c)\n\nVariable `Component` is not in your data frame :/\n\n\n\n\n\nThe following code chunk is the revised model:\n\nmodel1 <- lm(Price ~ Age_08_04 + KM + Weight + Guarantee_Period,\n            data = car_resale)\nmodel1\n\n\nCall:\nlm(formula = Price ~ Age_08_04 + KM + Weight + Guarantee_Period, \n    data = car_resale)\n\nCoefficients:\n     (Intercept)         Age_08_04                KM            Weight  \n      -2.186e+03        -1.195e+02        -2.406e-02         1.972e+01  \nGuarantee_Period  \n       2.682e+01  \n\n\nChecking Normality Assumption:\n\ncheck_n <- check_normality(model1)\nplot(check_n)\n\n\n\n\nWe can also perform the complete model diagnostic by using check_model().\n\ncheck_model(model1)\n\nVariable `Component` is not in your data frame :/\n\n\n\n\n\nThe code chunk below groups the observation by Race, computes the count of observations, mean, standard deviation and standard error of Maths by Race and saves the output as a tibble data table called my_sum.\n\nmy_sum <- exam_data %>%\n  group_by(RACE) %>%\n  summarise(n = n(),\n            mean = mean(MATHS),\n            sd = sd(MATHS)) %>%\n  mutate(se = sd / sqrt(n - 1))\n\nThe code chunk below is used to reveal the standard error of mean Maths score by Race.\n\nggplot(my_sum) +\n  geom_errorbar(aes(x = RACE,\n                    ymin = mean - se,\n                    ymax = mean + se),\n                width = 0.2,\n                color = \"black\",\n                alpha = 0.9,\n                size = 0.5) +\n  geom_point(aes(x = RACE,\n                 y = mean),\n             stat = \"identity\",\n             color = \"red\",\n             size = 1.5,\n             alpha = 1) +\n  ggtitle(\"Standard error of mean Maths score by Race\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead."
  },
  {
    "objectID": "In_Class_Ex/In_Class_Ex05/In_Class_Ex05.html",
    "href": "In_Class_Ex/In_Class_Ex05/In_Class_Ex05.html",
    "title": "In_Class_Ex05",
    "section": "",
    "text": "The following code chunk will install the necessary R packages.\n\npacman::p_load(corrplot, tidyverse, ggstatsplot, plotly, seriation, dendextend, heatmaply, GGally, parallelPlot)\n\nggtern is commented off in this exercise.\nThe code chunk below will import the dataset.\n\nwine <- read_csv(\"data/wine_quality.csv\")\n\nRows: 6497 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (1): type\ndbl (12): fixed acidity, volatile acidity, citric acid, residual sugar, chlo...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThe code chunk below will plot a scatter plot matrix of Wine Quality Data. This will be a 11 by 11 matrix.\n\npairs(wine[,1:11])\n\n\n\n\nWe can use ggcorrmat() to visualize a correlation matrix as it can provide a comprehensive and professional statistical report.\nThe code chunk below plots a correlation matrix using ggcorrmat().\n\nggstatsplot::ggcorrmat(data = wine,\n                       cor.vars = 1:11)\n\n\n\n\nThe code chunk below customizes the correlation matrix.\n\nggstatsplot::ggcorrmat(data = wine,\n                      cor.vars = 1:11,\n                      ggccorrplot.args = list(outline.color = \"black\",\n                                              hc.order = TRUE,\n                                              tl.cex = 10),\n                      title = \"Correlogram for wine dataset\",\n                      subtitle = \"Four pairs are no significant at p < 0.05\")\n\n\n\n\nIn the code chunk below, the cor() of R Stats will be used to compute the correlation matrix of the wine data frame.\n\nwine.cor <- cor(wine[,1:11])\n\nNext, corrplot() will be used to plot the corrgram by using the default settings.\n\ncorrplot(wine.cor)\n\n\n\n\nWe can change the default setting using the method argument:\n\ncorrplot(wine.cor,\n         method = \"ellipse\")\n\n\n\n\nWe can also design the corrgram to have a mixed visual matrix to display one half as an ellipse and another half as a number.\n\ncorrplot.mixed(wine.cor,\n               lower = \"ellipse\",\n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n\n\n\n\nWe can also draw rectangles around the corrgram based on the results of the hierarchical clustering.\n\ncorrplot(wine.cor,\n         method = \"ellipse\",\n         tl.pos = \"lt\",\n         tl.cos = \"black\",\n         order = \"hclust\",\n         hclust.method = \"ward.D\",\n         addrect = 3)\n\nWarning in text.default(pos.xlabel[, 1], pos.xlabel[, 2], newcolnames, srt =\ntl.srt, : \"tl.cos\" is not a graphical parameter\n\n\nWarning in text.default(pos.ylabel[, 1], pos.ylabel[, 2], newrownames, col =\ntl.col, : \"tl.cos\" is not a graphical parameter\n\n\nWarning in title(title, ...): \"tl.cos\" is not a graphical parameter\n\n\n\n\n\nWe will now be importing the data as part of the hands-on exercise for building a ternary plot with R.\n\npop_data <- read_csv(\"data/respopagsex2000to2018_tidy.csv\")\n\nRows: 108126 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): PA, SZ, AG\ndbl (2): Year, Population\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThe following code chunk uses the mutate() function of dplyr package to derive three new measures, namely Young, Active and Old.\n\nagpop_mutated <- pop_data %>%\n  mutate('Year' = as.character(Year)) %>%\n  spread(AG, Population) %>%\n  mutate(YOUNG = rowSums(.[4:8])) %>%\n  mutate(ACTIVE = rowSums(.[9:16])) %>%\n  mutate(OLD = rowSums(.[17:21])) %>%\n  mutate(TOTAL = rowSums(.[22:24])) %>%\n  filter(Year == 2018) %>%\n  filter(TOTAL > 0) %>%\n  select(PA, SZ, YOUNG, ACTIVE, OLD, TOTAL)\n\nWe will now use the ggtern() function of ggtern package to create a simple ternary plot. –>\nThe code chunk below has been written in plain text due to the issue with ggtern.\nggtern(data = agpop_mutated, aes(x = YOUNG, y = ACTIVE, z = OLD)) + geom_point()\nWe can also customize this plot:\nggtern(data = agpop_mutated, aes(x = YOUNG, y = ACTIVE, z = OLD)) + geom_point() + labs(title = “Population Structure, 2015”) + theme_rgbw()\nWe will now be importing the data as part of the hands-on exercise for building a heatmap in R.\n\nwh <- read_csv(\"data/WHData-2018.csv\")\n\nRows: 156 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): Country, Region\ndbl (10): Happiness score, Whisker-high, Whisker-low, Dystopia, GDP per capi...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThe following code chunk will change the rows by country name instead of row number.\n\nrow.names(wh) <- wh$Country\n\nWarning: Setting row names on a tibble is deprecated.\n\n\nWe will now load the data into a data frame and create a data matrix.\n\nwh1 <- dplyr::select(wh, c(3, 7:12))\nwh_matrix <- data.matrix(wh)\n\nThe following code chunk will create the heatmap using heatmap() of Base Stats.\n\nwh_heatmap <- heatmap(wh_matrix,\n                      Rowv = NA,\n                      Colv = NA)\n\n\n\n\nThe following code chunk uses the Blues colour palette of rColorBrewer:\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"none\",\n          colors = Blues)\n\n\n\n\n\nWe can include additional arguments to ensure that a cartographic quality heatmap can be produced.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          Colv = NA,\n          seriate = \"none\",\n          colors = Blues,\n          k_row = 5,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main = \"World Happiness Score and Variables by Country, 2018 \\nDataTransformation using Normalise Method\",\n          xlab = \"World Happiness Indicators\",\n          ylab = \"World Countries\")\n\n\n\n\n\nWe will now be importing the data as part of the hands-on exercise for building a heatmap in R.\n\nwhNew <- read_csv(\"data/WHData-2018.csv\")\n\nRows: 156 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): Country, Region\ndbl (10): Happiness score, Whisker-high, Whisker-low, Dystopia, GDP per capi...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nWe can use ggparcoord() to plot a basic static parallel coordinates plot.\n\nggparcoord(data = whNew,\n           columns = c(7:12))\n\n\n\n\nWe can use the code chunk below to plot an interactive parallel coordinates plot using parallelPlot().\n\nhistoVisibility <- rep(TRUE, ncol(wh))\nparallelPlot(wh,\n             rotateTitle = TRUE,\n             histoVisibility = histoVisibility)"
  },
  {
    "objectID": "Take_Home_Ex/Take_Home_Ex01/Take_Home_Ex01.html",
    "href": "Take_Home_Ex/Take_Home_Ex01/Take_Home_Ex01.html",
    "title": "Take-Home Exercise 1",
    "section": "",
    "text": "The following is my submission for Take-Home Exercise 1.\n\nDataset\nThe dataset used in this take-home exercise was downloaded from the following link, below the sub-section of Population Trends: https://www.singstat.gov.sg/find-data/search-by-theme/population/geographic-distribution/latest-data\nWe are using the Singapore Residents by Planning Area / Subzone, Age Group, Sex and Floor Area of Residence, June 2022.csv for this exercise. Once downloaded and unzipped, there are two files that are contained in this folder; one for the raw dataset and one for the notes of the dataset (similar to a readme file).\nUnzipped folder:\n\nDataset:\n\nNotes of Dataset:\n\n\n\nPreparation Steps\nPlease find below a reproducible description of the procedures used to prepare and create the analytical visualization in Tableau Desktop.\n\n\n\n\n\n\n\n\nNo.\nStep\nScreenshot\n\n\n1\nIn Tableau Desktop, in the Data Source pane, click on “Text file”.\nWhen prompted to choose a file, click on the raw dataset.\n\n\n\n\n2\nLet’s change the data source name to: Planning Area - Jun 2022.\nLet’s also change the field names according to the Notes of Dataset csv file.\n\n\n\n\n\n\n3\nThe field Time has been identified to be a numerical field. However, this is incorrect as it is supposed to reflect the Year of the record.\nLet’s change Time field’s datatype to Date.\n\n\n\n\n\n4\nLet’s create two calculated fields to distinguish the populations by gender.\nCreate a calculated field called Male Population and Female Population.\n\n\n\n\n\n5\nLet’s group the values in the Age Group field into bins of 15 to simplify our analysis.\n\n\n\n\n6\nTo show only 9 Planning Areas in our view, let’s filter the data source to only keep the Top 9 Planning Areas based on the total population.\nClick on “Add” to add a new data source filter.\nIn the Data Source Filters popup, click on “Add” to add a new filter for the Planning Area field.\nWhen prompted to choose which values to keep, select the tab “Top”, and the radio button “By field” to choose the Top 9 by Population Sum.\nClick on “Ok” to close the popup.\nClick on “Ok” again to close the Data Source Filters popup.\n\n\n\n\n\n\n\n\n7\nNow, let’s build the visualization in “Sheet 1”.\nLet’s create two calculated fields; one for columns and one for rows, to build a 3 by 3 matrix.\nDrag Columns and Rows fields to the Column and Row panes respectively. The view will look like a quadrant.\nSwitch the Columns and Rows fields from Continuous to Discrete. The view will be updated to a table.\n\n\n\n\n\n\n\n8\nDrag the two calculated fields we created (Male Population & Female Population) to the Columns pane.\nDrag the Age Group (Group) field to the Rows pane.\n\n\n\n9\nRight click on the axis for Male Population field and select “Edit Axis”.\nIn the popup, under the section “Scale”, tick the check-box for “Reversed”.\n\n\n\n\n\n10\nDrag the Planning Area field into the Details section of the All marks card.\n\n\n\n11\nLet’s update how the calculated fields Columns and Rows are computed - which should be based on the Planning Area field.\n\n\n\n\n12\nIn the marks card for Male Population field, change the color to teal.\nSimilarly, in the marks card for Female Population field, change the color to red.\n\n\n\n\n13\nLet’s change the view from”Standard” to “Entire View” to spread out our display.\n\n\n\n14\nLet’s remove the axis headers for both Male Population and Female Population fields.\nRight click on the axis header and un-check “Show Header” for either of the axis.\nLet’s also remove the header for the Columns and Rows fields. Un-check “Show Header” for both these fields.\n\n\n\n\n\n15\nUnder the marks card for All, drag the slider to reduce the size of the bars till the recommended size (indicated by a pipe).\n\n\n\n16\nTo format grid line, right click on the view and select the “Format” option.\nIn the format panel, click on the icon for grid lines. Under the tab “Columns”, set Grid Lines to None.\n\n\n\n\n17\nFor the male population marks card, let’s drag the SUM(Male Population) field to the label section. Right click on the SUM(Male Population) field in the marks card and click on “Format”.\nIn the format panel, click on “Pane”. Under the “Numbers” option, select “Custom”. Change the number of decimal places to 0 and the display units to thousands.\nRepeat the same for the SUM(Female Population) field.\n\n\n\n\n\n18\nRight click on Age Group (Group) field in the Rows pane and select “Sort”.\nIn the popup, change the sort order to “Descending”.\n\n\n\n\n19\nRight click the Planning Area field in the marks card for All and select “Sort”.\nLet’s sort by Sum of Population in Descending Order.\n\n\n\n\n20\nTo bring the Planning Area field as a text label for this view, let’s create a calculated field called dummy.\n\n\n\n\n21\nBring this new calculated field, dummy, into the view on the Columns panel. Ensure that the dummy field is taking the AVG and not the SUM.\nMake this dummy field a dual axis with the Female Population field.\nRight click on the axis header for the dummy field and click on “Synchronize Axis”.\n\n\n\n\n\n22\nNow, let’s format this dummy field. Right click on the dummy field’s axis header and un-check “Show Header”.\nLet’s also un-check “Show Header” for the Female Population field.\n\n\n\n\n23\nLet’s remove the measure names field from the colors section in the marks card for both the dummy and Female Population fields.\n\n\n\n\n\n\n24\nLet’s also reduce the size of the bars for the dummy field to the smallest possible size.\n\n\n\n25\nMake the dummy field’s color to be completely opaque with no borders.\n\n\n\n26\nChange the type of mark from “Bar” into “Circle” for the dummy field.\nThen, drag the Planning Area field into the text section in the marks card.\n\n\n\n\n\n27\nFormat the text label to be bigger and bold, as well as center-aligned.\nNow we have a clean and insightful view that is ready for analysis!\n\n\n\n\n\n\n\n\nDiscussion of Analysis\nSo, what can we learn from this visualization that we built in Tableau Desktop?\n\n\n\n\n\nFirstly, when we look at the Top 9 Planning Areas, namely Bedok, Tampines, Jurong West, Sengkang, Woodlands, Hougang, Yishun, Chua Chu Kang and Punggol, there is one thing that is common. They are all HDB Residential Areas.\nLet us now analyse this view by the Age Groups. Across the Planning Areas, a key thing to note would be that Bedok is the only area which has at least 1K population for both Males and Females who are above the age of 90. Moreover, they also have the highest population of both Males and Females who are between the ages of 75 and 89. From this, we can deduce that Bedok hosts one of the highest populations of elderly who are above the age of 75.\n\n\n\n\n\nIf we look at the opposite spectrum in the Age Group, both Sengkang and Punggol seem to have the largest population of Males and Females between the ages of 0 to 14. This could indicate that these Planning Areas are most likely to host younger families who are raising children and adolescents.\nThere are only 2 out of these 9 Planning Areas, namely Sengkang and Punggol, which have a higher population in the age group of 0 to 14 as when compared to the age group of 15 to 29. Meaning they have more people below the age of 14 than in the ages between 15 to 29. Whereas, for the other 7 Planning Areas, this is the opposite, indicating a low fertility rate in general.\nWhen looking at Age Groups and Planning Areas, one section that stands out would be the Planning Area of Punggol. This is because it is notable that the population between the ages of 30 to 44 is almost the double of the population between the ages of 15 to 29. This is something that we could further analyse as a future work.\n\n\n\n\n\nMoving on to the breakdown by Gender, we can determine that there are more Males than Females in the ages between 0 to 14 across all the Top 9 Planning Areas. On the other hand, there are more Females than Males in the ages between 30 to 44 across all the Top 9 Planning Areas.\nLast but not least, in overall, the populations across these Planning Areas seems to be a well distributed for both genders. This implies that we have a reasonably good gender equality in our Top 9 Planning Areas.\nThis concludes the work submitted for Take-Home Exercise 1. Thank you!"
  },
  {
    "objectID": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html",
    "href": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html",
    "title": "Take-Home Exercise 2",
    "section": "",
    "text": "The following is my submission for Take-Home Exercise 2."
  },
  {
    "objectID": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html#overview",
    "href": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html#overview",
    "title": "Take-Home Exercise 2",
    "section": "1. Overview",
    "text": "1. Overview\nThis take-home exercise is based on a submission done by a classmate for Take-Home Exercise 1. The aim of this exercise is to critique the visualization prepared by that classmate in terms of clarity and aesthetics. On top of that, an alternative design of the original visualization will be done using the data visualization design principles."
  },
  {
    "objectID": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html#dataset",
    "href": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html#dataset",
    "title": "Take-Home Exercise 2",
    "section": "2. Dataset",
    "text": "2. Dataset\n\n2.1 Data Source\nThe dataset used in this take-home exercise was downloaded from the following link, below the sub-section of Population Trends: https://www.singstat.gov.sg/find-data/search-by-theme/population/geographic-distribution/latest-data\nWe are using the Singapore Residents by Planning Area / Subzone, Age Group, Sex and Floor Area of Residence, June 2022.csv for this exercise.\n\n\n\n\n\n\n\n2.2 Data Preparation\nData preparation steps that were done by the classmate of the visualization that we will be critiquing is as follows.\nLoad libraries and dataset:\n\n\nCode\npacman::p_load(ggplot2, ggiraph, dplyr, tidyverse)\n\npa_data <- read_csv(\"respopagesexfa2022.csv\") \n\n\nGet Top 9 Planning Areas by Population:\n\n\nCode\n# Total population count by planning area\npop <- pa_data %>%\n  group_by(PA) %>%\n  summarize(totalPop = sum(Pop))\n\n# Sort planning areas by population\npop_sorted <- pop[order(pop$totalPop, decreasing = TRUE), ]\n\n# Get top 9 planning areas by population\npop_filtered <- head(pop_sorted, 9)\npop_filtered$index <- 1:nrow(pop_filtered)\n\n# Filter raw dataset to keep the top 9 planning areas by population\npa_filtered <- subset(pa_data, PA %in% pop_filtered$PA)\n\n\nSort dataset by Top 9 Planning Areas and Age Group:\n\n\nCode\n# Group dataset by planning areas, age group and sex\npa_grouped <- aggregate(Pop ~ PA + AG + Sex, data = pa_filtered, FUN = sum)\n\n# Sort dataset by top 9 planning areas and age group\nordered <- c(\"0_to_4\", \"5_to_9\", \"10_to_14\", \"15_to_19\", \"20_to_24\", \"25_to_29\", \"30_to_34\", \"35_to_39\", \"40_to_44\", \"45_to_49\", \"50_to_54\", \"55_to_59\", \"60_to_64\", \"65_to_69\", \"70_to_74\", \"75_to_79\", \"80_to_84\", \"85_to_89\", \"90_and_over\")\npa_final <- pa_grouped %>%\n  mutate(PA = factor(PA, levels = pop_filtered$PA)) %>%\n  mutate(AG = factor(AG, levels = ordered)) %>%\n  arrange(PA, AG)"
  },
  {
    "objectID": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html#visualization-critique",
    "href": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html#visualization-critique",
    "title": "Take-Home Exercise 2",
    "section": "3. Visualization Critique",
    "text": "3. Visualization Critique\n\n3.1 Original Design\nThe original design is shown below:\n\n\n\n\n\nThis visualization, a faceted bar chart, plots Singapore’s Top 9 Planning Areas by Population Count, whereby the age-sex pyramid is coloured by gender for each of the different age groups.\n\n\n3.2 Critique\n\n3.2.1 Clarity\n\nDisplay of Data Labels\n\nThere are text labels for the bars in the age-sex pyramid and this makes the visualization cluttered. Besides, these text labels will draw the user’s attention away from the shape of the age-sex pyramid. Moreover, the text labels are not shown for every bar in the visualization, which could lead to assumptions and confusion as to why only certain values are being shown.\n\nAlignment of Totals\n\nThe labels for the totals, such as “Hougang 623,660” and “Sengkang 720,530” are positioned in a confusing manner as they seem to be in the wrong grids in the visual, and this might be misleading as users might interpret the grids in the visualization incorrectly. Another thing to note would be that these total values seem to be incorrect upon data validation, and this could confuse users as well.\n\nLegends\n\nIt might be easy to overlook the colour-coded text in the subtitle of this chart, however this subtitle seems to represent the legends of this visualization - Blue for Male and Pink for Female. Since it is not explicitly stated, the users may misinterpret the sex assigned to the colour-coded bars in this visualization.\n\n\n3.2.2 Aesthetics\n\nColours\n\nThe colours chosen to indicate the two different genders in this visualization are clear and distinguishable. However, the addition of legends to indicate the values assigned to these colours would be beneficial for users.\n\nX-Axis Title & Labels\n\nThis visualization does not show the x-axis title and labels. It would be easier to read and interpret the visualization if the x-axis indicated that it is referring to the population count.\n\nCaptions\n\nIncluding a caption to mention the data source for this visualization will be helpful for users as well."
  },
  {
    "objectID": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html#alternative-design",
    "href": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html#alternative-design",
    "title": "Take-Home Exercise 2",
    "section": "4. Alternative Design",
    "text": "4. Alternative Design\n\n4.1 Sketch\n\n\n\n\n\nIn the alternative design, as per the sketch shown above, the proposal is to include the rank and total population count of each of the top 9 planning areas in the grid view, as well as the inclusion of graphical elements such as caption, legend and x-axis labels.\n\n\n4.2 Remake\n\n\nCode\n# Labels to be shown in the header\nlabel <- function(string) {\n  label <- paste0(pop_filtered$index, \n                  '. ', \n                  string, \n                  ' (Pop = ', \n                  format(pop_filtered$totalPop, \n                         big.mark = \",\", \n                         scientific = FALSE), ')')\n  label\n}\n\nageSexPyramid <- ggplot(pa_final,\n                        aes(x = ifelse(Sex == \"Males\",\n                                       yes = -Pop, \n                                       no = Pop),\n                            y = AG,\n                            fill = Sex)) +\n  geom_col_interactive(width = 0.5,\n                       aes(tooltip = paste0(\"Pop for \", Sex, \": \", Pop))) +\n  facet_wrap(~ PA, labeller = labeller(PA = label)) +\n  theme_bw() +\n  scale_fill_manual(values = c(\"Males\" = \"lightblue\", \n                               \"Females\" = \"lightpink\")) +\n  labs(x = \"Population\",\n       y = \"Age Group\",\n       title = \"Singapore's Constrictive Age-Sex Pyramid\",\n       subtitle = \"Top 9 Planning Areas by Population, 2022\",\n       caption = \"Data Source: https://www.singstat.gov.sg/find-data/search-by-theme/population/geographic-distribution/latest-data\") +\n  guides(fill = guide_legend(direction = \"horizontal\")) +\n  theme(plot.title = element_text(hjust = 0.5,\n                                  size = 18),\n        plot.subtitle = element_text(hjust = 0.5,\n                                     size = 12),\n        plot.caption = element_text(hjust = 0),\n        legend.position = c(1, 1.05),\n        legend.justification = \"right\")\n\nfig <- girafe(ggobj = ageSexPyramid)\nfig\n\n\n\n\n\n\nThis makeover graph retains the good features of the original graph. This includes the overall format as well as graphical elements such as title, subtitle and grid lines. The colour scheme for the bar charts are also retained as it is clear and distinguishable.\n\n4.2.1 Clarity\n\nData Labels in Tooltips\n\nTo be clear and consistent in the display of data labels, they have been placed in the tooltips for each of the bars in the visualization. Moreover, this display declutters the view and does not draw the user’s attention away from the shape of the age-sex pyramid.\n\nAlignment of Totals\n\nThe labels for the totals have now been placed clearly at the header section of each grid, while also indicating the rank of the planning area in the Top 9. For example, it is clear that Bedok is the number one planning area with a population total of 278,870.\n\nLegends\n\nIn the remake, it is explicitly indicated that the colour-coded bars are based on the field Sex, as shown in the legends in the top-right corner of this visualization.\n\n\n4.2.2 Aesthetics\n\nColours\n\nThe colours chosen to indicate the two different genders in this visualization are clear and distinguishable. With the addition of well-placed legends, it is also explicit and avoids the case of misinterpretations.\n\nX-Axis Title & Labels\n\nWith the aid of the newly added x-axis title and labels, it makes it easier for users to read and interpret this visualization.\n\nCaption\n\nThe caption to mention the data source for this visualization has also been included at the bottom in a clean manner."
  },
  {
    "objectID": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html#learning-points",
    "href": "Take_Home_Ex/Take_Home_Ex02/Take_Home_Ex02.html#learning-points",
    "title": "Take-Home Exercise 2",
    "section": "5. Learning Points",
    "text": "5. Learning Points\nThis take-home exercise has helped me realize the different ways I could have worked on take-home exercise 01. By analyzing and exploring my classmates’ works, I have gathered more ideas that would definitely come in handy in my future work. Moreover, I managed to explore ggplot2 with the hands-on practice of creating this visualization, and have learned how we can use ggiraph to create interactive plots as well.\nThis concludes the work submitted for Take-Home Exercise 2. Thank you!"
  },
  {
    "objectID": "Take_Home_Ex/Take_Home_Ex03/Take_Home_Ex03.html",
    "href": "Take_Home_Ex/Take_Home_Ex03/Take_Home_Ex03.html",
    "title": "Take-Home Exercise 3",
    "section": "",
    "text": "The following is my submission for Take-Home Exercise 3."
  },
  {
    "objectID": "Take_Home_Ex/Take_Home_Ex03/Take_Home_Ex03.html#data-source",
    "href": "Take_Home_Ex/Take_Home_Ex03/Take_Home_Ex03.html#data-source",
    "title": "Take-Home Exercise 3",
    "section": "2.1 Data Source",
    "text": "2.1 Data Source\nThe dataset used in this take-home exercise was downloaded from the following link: https://data.gov.sg/dataset/resale-flat-prices\nWe are using the Resale flat prices based on registration date from Jan-2017 onwards csv file for this exercise."
  },
  {
    "objectID": "Take_Home_Ex/Take_Home_Ex03/Take_Home_Ex03.html#data-preparation",
    "href": "Take_Home_Ex/Take_Home_Ex03/Take_Home_Ex03.html#data-preparation",
    "title": "Take-Home Exercise 3",
    "section": "2.2 Data Preparation",
    "text": "2.2 Data Preparation\nFirst, let’s load the dataset and the libraries that we will be using:\n\npacman::p_load(tidyverse, lubridate, plotly, treemap, ggstatsplot)\nrawData <- read_csv(\"resale-flat-prices-based-on-registration-date-from-jan-2017-onwards.csv\")\n\nLet’s take a look at this dataset:\n\nhead(rawData)\n\n# A tibble: 6 × 11\n  month   town     flat_…¹ block stree…² store…³ floor…⁴ flat_…⁵ lease…⁶ remai…⁷\n  <chr>   <chr>    <chr>   <chr> <chr>   <chr>     <dbl> <chr>     <dbl> <chr>  \n1 2017-01 ANG MO … 2 ROOM  406   ANG MO… 10 TO …      44 Improv…    1979 61 yea…\n2 2017-01 ANG MO … 3 ROOM  108   ANG MO… 01 TO …      67 New Ge…    1978 60 yea…\n3 2017-01 ANG MO … 3 ROOM  602   ANG MO… 01 TO …      67 New Ge…    1980 62 yea…\n4 2017-01 ANG MO … 3 ROOM  465   ANG MO… 04 TO …      68 New Ge…    1980 62 yea…\n5 2017-01 ANG MO … 3 ROOM  601   ANG MO… 01 TO …      67 New Ge…    1980 62 yea…\n6 2017-01 ANG MO … 3 ROOM  150   ANG MO… 01 TO …      68 New Ge…    1981 63 yea…\n# … with 1 more variable: resale_price <dbl>, and abbreviated variable names\n#   ¹​flat_type, ²​street_name, ³​storey_range, ⁴​floor_area_sqm, ⁵​flat_model,\n#   ⁶​lease_commence_date, ⁷​remaining_lease\n\nsummary(rawData)\n\n    month               town            flat_type            block          \n Length:146872      Length:146872      Length:146872      Length:146872     \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n street_name        storey_range       floor_area_sqm   flat_model       \n Length:146872      Length:146872      Min.   : 31.0   Length:146872     \n Class :character   Class :character   1st Qu.: 82.0   Class :character  \n Mode  :character   Mode  :character   Median : 94.0   Mode  :character  \n                                       Mean   : 97.6                     \n                                       3rd Qu.:113.0                     \n                                       Max.   :249.0                     \n lease_commence_date remaining_lease     resale_price    \n Min.   :1966        Length:146872      Min.   : 140000  \n 1st Qu.:1985        Class :character   1st Qu.: 358000  \n Median :1996        Mode  :character   Median : 448000  \n Mean   :1996                           Mean   : 478316  \n 3rd Qu.:2007                           3rd Qu.: 565800  \n Max.   :2019                           Max.   :1418000  \n\n\nAs you can see, the month column is in the format of YYYY-MM. Using the month column, we can actually create two new columns - Date (in YYYY-MM-DD format) and Year. These fields will be useful when building visualizations.\n\ndata <- rawData %>%\n  mutate(Year = year(ym(month))) %>%\n  mutate(Date = as.Date(paste(month, \"-01\", sep = \"\"),\n                        format = \"%Y - %m - %d\"))\nsummary(data)\n\n    month               town            flat_type            block          \n Length:146872      Length:146872      Length:146872      Length:146872     \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n street_name        storey_range       floor_area_sqm   flat_model       \n Length:146872      Length:146872      Min.   : 31.0   Length:146872     \n Class :character   Class :character   1st Qu.: 82.0   Class :character  \n Mode  :character   Mode  :character   Median : 94.0   Mode  :character  \n                                       Mean   : 97.6                     \n                                       3rd Qu.:113.0                     \n                                       Max.   :249.0                     \n lease_commence_date remaining_lease     resale_price          Year     \n Min.   :1966        Length:146872      Min.   : 140000   Min.   :2017  \n 1st Qu.:1985        Class :character   1st Qu.: 358000   1st Qu.:2018  \n Median :1996        Mode  :character   Median : 448000   Median :2020  \n Mean   :1996                           Mean   : 478316   Mean   :2020  \n 3rd Qu.:2007                           3rd Qu.: 565800   3rd Qu.:2021  \n Max.   :2019                           Max.   :1418000   Max.   :2023  \n      Date           \n Min.   :2017-01-01  \n 1st Qu.:2018-09-01  \n Median :2020-07-01  \n Mean   :2020-03-27  \n 3rd Qu.:2021-10-01  \n Max.   :2023-02-01  \n\n\nSince we will only be focusing on the year 2022, we will filter the dataset to only keep records for the year 2022. Also, we only want to work with records which have a flat type of 3-Room, 4-Room or 5-Room. Let’s filter the data to meet this condition.\n\nresaleFlats <- data %>%\n  filter(Year == \"2022\") %>%\n  filter(flat_type %in% c(\"3 ROOM\", \"4 ROOM\", \"5 ROOM\"))\nhead(resaleFlats)\n\n# A tibble: 6 × 13\n  month   town     flat_…¹ block stree…² store…³ floor…⁴ flat_…⁵ lease…⁶ remai…⁷\n  <chr>   <chr>    <chr>   <chr> <chr>   <chr>     <dbl> <chr>     <dbl> <chr>  \n1 2022-01 ANG MO … 3 ROOM  320   ANG MO… 07 TO …      73 New Ge…    1977 54 yea…\n2 2022-01 ANG MO … 3 ROOM  225   ANG MO… 07 TO …      67 New Ge…    1978 55 yea…\n3 2022-01 ANG MO … 3 ROOM  331   ANG MO… 07 TO …      68 New Ge…    1981 58 yea…\n4 2022-01 ANG MO … 3 ROOM  534   ANG MO… 07 TO …      82 New Ge…    1980 57 yea…\n5 2022-01 ANG MO … 3 ROOM  578   ANG MO… 04 TO …      67 New Ge…    1980 57 yea…\n6 2022-01 ANG MO … 3 ROOM  452   ANG MO… 01 TO …      83 New Ge…    1979 56 yea…\n# … with 3 more variables: resale_price <dbl>, Year <dbl>, Date <date>, and\n#   abbreviated variable names ¹​flat_type, ²​street_name, ³​storey_range,\n#   ⁴​floor_area_sqm, ⁵​flat_model, ⁶​lease_commence_date, ⁷​remaining_lease\n\n\nThe data is now ready for visualization."
  }
]